/*
 * ======================================================================================
 * 类别：经典问题——日期计算
 *
 * 题目：高斯日记
 *
 * 【描述】
 * 高斯有个好习惯：无论如何都要记日记。他的日记有个与众不同的地方，他从不注明年月日，
 * 而是用一个整数代替，比如：4210。
 * 后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。
 * 这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？
 *
 * 高斯出生于：1777年4月30日。
 * 在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。
 *
 * 给定高斯日记中的一个标注（即第N天），请计算具体是哪天？
 * 输出格式为 yyyy-mm-dd，例如：1980-03-21。
 *
 * 【输入】
 * 输入一个整数 N。
 *
 * 【输出】
 * 输出对应的日期，格式为 yyyy-mm-dd。
 *
 * 【样例输入】
 * 5343
 *
 * 【样例输出】
 * 1791-12-15
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 基础数据准备：
 * - 需要一个数组 `month[13]` 存储每个月的天数（平年）。
 * - 定义一个结构体 `Date` 来存储年、月、日。
 * - 初始化日期为高斯的生日：1777年4月30日。
 *
 * 2. 闰年判断：
 * - 写一个辅助函数 `is_leap(year)`。
 * - 规则：能被4整除但不能被100整除，或者能被400整除的年份是闰年。
 * - 闰年的2月有29天，平年28天。
 *
 * 3. 模拟推演：
 * - 题目给出的 N 是“第N天”。如果 N=1，就是出生当天。
 * - 因此，我们需要往后推演 N-1 天。使用 `while(--N)` 循环即可。
 * - 在循环中，每次让天数加 1 (`now.d++`)。
 *
 * 4. 处理进位：
 * - **日进位**：如果当前天数 `now.d` 超过了当前月份的最大天数 `month[now.m]`：
 * - 天数重置为 1。
 * - 月份加 1 (`now.m++`)。
 * - **月进位**：如果当前月份 `now.m` 超过了 12：
 * - 月份重置为 1。
 * - 年份加 1 (`now.y++`)。
 * - **关键点**：年份变化后，需要立即判断新的一年是否为闰年，并更新二月的天数 (`month[2]`)。
 *
 * 5. 输出：
 * - 使用 printf 的格式化输出 `%04d-%02d-%02d` 保证位数对齐（不足补0）。
 *
 * ======================================================================================
 */

#include <stdio.h>

// 存放平年每个月的天数，索引0不使用，1-12对应1-12月
// 注意：month[2] 在程序运行中会根据闰年动态修改
int month[13] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

// 定义日期结构体
struct Date {
    int y; // 年
    int m; // 月
    int d; // 日
};

// 判断是否为闰年的函数
// 返回 1 表示闰年，0 表示平年
int is_leap(int year) {
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
        return 1;
    return 0;
}

int main() {
    int N;
    struct Date now;

    // 初始化为高斯的生日 
    now.y = 1777;
    now.m = 4;
    now.d = 30;

    // 输入 N
    if (scanf("%d", &N) != 1) return 1;

    // 循环 N-1 次，模拟一天天过
    // 比如 N=1，循环不执行，直接输出生日
    // N=2，循环执行1次，日期加1天
    while (--N) {
        now.d++; // 日期加1

        // 检查当前天数是否超过当前月份的最大天数
        if (now.d > month[now.m]) {
            now.d = 1;  // 重置为当月1号
            now.m++;    // 进入下一个月

            // 检查月份是否超过12
            if (now.m > 12) {
                now.m = 1;  // 重置为1月
                now.y++;    // 进入下一年

                // 新的一年，需要更新2月的天数 
                if (is_leap(now.y))
                    month[2] = 29;
                else
                    month[2] = 28;
            }
        }
    }

    // 按格式输出结果，%02d表示不足两位左边补0
    printf("%04d-%02d-%02d\n", now.y, now.m, now.d);

    return 0;
}

/*
 * ======================================================================================
 * 类别：经典问题——查找
 *
 * 题目：近似幸运数统计
 *
 * 【描述】
 * 明明喜欢 7 这个数字，如果一个数的十进制表示中含有 7，则该数为明明的“幸运数”。
 * 例如 7，78，17 都是幸运数，而 168 不是幸运数。
 *
 * 如果一个数能够被幸运数整除，则称之为“近似幸运数”。
 * 例如 14 能被 7 整除，是一个近似幸运数。
 * 注意：幸运数本身也是近似幸运数（能被自己整除）。
 *
 * 现给定两个正整数 a, b，请输出这个区间 [a, b] 内（含区间首尾）
 * 既不是幸运数也不是近似幸运数的那些数的数量。
 * 如果不存在，则输出 0。
 *
 * 【输入】
 * 输入两个整数 a, b (1 <= a, b <= 1,000,000)。
 *
 * 【输出】
 * 输出一个数，表示 [a, b] 区间中满足条件的数的数量。
 *
 * 【样例输入】
 * 1 10
 *
 * 【样例输出】
 * 9
 * (解释：1到10中，只有7是幸运数（也是近似幸运数），其他9个数都满足条件)
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 问题分析：
 * - 数据范围上限是 1,000,000。如果对每个数单独判断是否能被某个幸运数整除，复杂度会很高。
 * - 适合使用“筛法”进行预处理。
 *
 * 2. 预处理 (Pre-process)：
 * - 定义一个标记数组 `is_almost_lucky[]`，初始化为 0 (false)。
 * - 遍历从 1 到 1,000,000 的每一个数 i：
 * a. 检查 i 是否已经被标记为近似幸运数。
 * 如果已经被标记（比如 14 被 7 标记过），且 14 本身也是幸运数（虽然 14 不是，假设有个数既是倍数又是幸运数），
 * 它的倍数一定已经被更小的幸运因子（如 7）筛过了，所以可以跳过，这是一个优化。
 * b. 如果 i 还没被标记，检查 i 是否是“幸运数”（含 7）。
 * - 如果是幸运数：
 * 那么 i 的所有倍数 (i, 2*i, 3*i ...) 都是近似幸运数。
 * 用一层循环将这些倍数在数组中标记为 1 (true)。
 *
 * 3. 统计结果：
 * - 读入 a, b。
 * - 遍历区间 [a, b]，统计标记数组中为 0 的个数。
 * - 或者统计为 1 的个数 ans，最后输出 (b - a + 1) - ans。
 *
 * 4. 辅助函数：
 * - `check_lucky(n)`: 判断 n 的十进制位中是否含有 7。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#define MAX_N 1000005

// 标记数组：is_almost_lucky[i] = 1 表示 i 是近似幸运数，0 表示不是
// 放在全局变量区，防止栈溢出，且默认初始化为0
int is_almost_lucky[MAX_N];

// 判断 n 是否为幸运数（含有数字7）
bool check_lucky(int n) {
    while (n > 0) {
        if (n % 10 == 7) {
            return true;
        }
        n /= 10;
    }
    return false;
}

// 预处理函数：筛选出所有的近似幸运数
void pre_process() {
    // 初始化数组（全局变量其实默认为0，这里为了严谨显式初始化）
    // memset(is_almost_lucky, 0, sizeof(is_almost_lucky));

    for (int i = 1; i < MAX_N; i++) {
        // 核心优化逻辑：
        // 如果 i 已经被标记为近似幸运数（说明它有更小的幸运因子），
        // 那么 i 的倍数一定也已经被那个更小的因子筛过了，所以不用处理。
        // 我们只需要处理那些 "本身是幸运数 且 还没被更小的幸运数筛过" 的数。
        if (is_almost_lucky[i] == 0) {
            if (check_lucky(i)) {
                // 如果 i 是幸运数，将它的所有倍数标记为近似幸运数
                // 注意：包括 i 本身 (j=1时)
                for (int j = 1; (long long)i * j < MAX_N; j++) {
                    is_almost_lucky[i * j] = 1;
                }
            }
        }
    }
}

int main() {
    // 1. 先进行预处理
    pre_process();

    int a, b;
    if (scanf("%d %d", &a, &b) != 2) return 1;

    // 确保 a <= b，虽然题目通常暗示 a <= b，但做个交换更保险
    if (a > b) {
        int temp = a;
        a = b;
        b = temp;
    }

    // 2. 统计区间内不满足条件的数
    int count = 0; // 记录近似幸运数的个数

    for (int i = a; i <= b; i++) {
        if (is_almost_lucky[i]) {
            count++;
        }
    }

    // 3. 输出结果
    // 总数 - 近似幸运数的个数 = 既不是幸运数也不是近似幸运数的个数
    printf("%d\n", (b - a + 1) - count);

    return 0;
}

/*
 * ======================================================================================
 * 类别：经典问题——模拟
 *
 * 题目：情报破译
 *
 * 【描述】
 * 詹姆斯在一次特工行动中获得了一份重要情报，但是情报被加密。
 * 经过破译，他知道了破译方法，需要 M 个步骤。
 * 用一个整数数组来表示待破译的情报。
 *
 * 【输入】
 * 第一行：两个正整数 N 和 M。
 * N 表示情报长度 (1 <= N <= 10000)。
 * M 表示破译所需的步骤数 (1 <= M <= 10000)。
 * 第二行：N 个整数，用空格隔开，表示初始加密的情报数组。
 * 接下来 M 行：每行输入三个整数 L、S、T。
 * L 取值 0、1、2，分别表示三种操作：
 * - L = 0: 加法操作。a[S] = a[S] + T (在索引 S 的位置加上 T)
 * - L = 1: 减法操作。a[S] = a[S] - T (在索引 S 的位置减去 T)
 * - L = 2: 交换操作。交换 a[S] 和 a[T] 的值 (S 和 T 为两个索引)
 * (注：数组索引从 0 开始计数)
 *
 * 【输出】
 * 输出一行，表示破译后的内容，元素间用空格分隔。
 *
 * 【样例输入】
 * 3 2
 * 1 2 3
 * 0 2 3
 * 2 0 1
 *
 * 【样例输出】
 * 2 1 6
 *
 * 【样例解释】
 * 初始: [1, 2, 3]
 * 操作1 (0 2 3): 在索引2位置加3 -> a[2] += 3 -> [1, 2, 6]
 * 操作2 (2 0 1): 交换索引0和1 -> swap(a[0], a[1]) -> [2, 1, 6]
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据结构：
 * - 使用一个整型数组 `a[10005]` 存储情报数据。
 * - 题目 N 最大为 10000，数组开稍大一点以防越界。
 *
 * 2. 初始化：
 * - 读入 N 和 M。
 * - 循环 N 次读入初始数组数据。
 *
 * 3. 模拟过程：
 * - 循环 M 次，处理每一步操作。
 * - 每次读入 L, S, T。
 * - 根据 L 的值进行判断（if-else 或 switch）：
 * - L == 0: 执行加法 `a[S] += T`。
 * - L == 1: 执行减法 `a[S] -= T`。
 * - L == 2: 执行交换。使用临时变量 `temp` 实现 `a[S]` 和 `a[T]` 的交换。
 *
 * 4. 输出：
 * - 遍历数组，输出所有元素，每个元素后跟一个空格。
 *
 * ======================================================================================
 */

#include <stdio.h>

// 定义最大数组大小，稍大于题目要求的 10000
#define MAX_N 10005

int main() {
    int a[MAX_N]; // 存放情报数据的数组
    int N, M;

    // 1. 输入 N 和 M
    if (scanf("%d %d", &N, &M) != 2) return 1;

    // 2. 输入初始情报数组
    for (int i = 0; i < N; i++) {
        scanf("%d", &a[i]);
    }

    // 3. 处理 M 个操作
    for (int i = 0; i < M; i++) {
        int L, S, T;
        scanf("%d %d %d", &L, &S, &T);

        if (L == 0) {
            // L=0: 加法操作
            // S是索引，T是增加的值
            a[S] += T;
        }
        else if (L == 1) {
            // L=1: 减法操作
            // S是索引，T是减去的值
            a[S] -= T;
        }
        else if (L == 2) {
            // L=2: 交换操作
            // S和T是两个需要交换的索引
            int temp = a[S];
            a[S] = a[T];
            a[T] = temp;
        }
    }

    // 4. 输出最终结果
    for (int i = 0; i < N; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");

    return 0;
}

/*
 * ======================================================================================
 * 类别：数学问题——进制转换
 *
 * 题目：任意进制转换
 *
 * 【描述】
 * 求任意两个不同进制非负整数的转换（2进制 ~ 16进制）。
 * 所给整数在 int 所能表达的范围之内。
 * 不同进制的表示符号为 (0,1,...,9, a,b,...,f) 或者 (0,1,...,9, A,B,...,F)。
 *
 * 【输入】
 * 输入只有一行，包含三个数据 a, n, b，用空格隔开。
 * - a: 原数据的进制 (2 <= a <= 16)
 * - n: 一个字符串，表示 a 进制下的整数
 * - b: 目标进制 (2 <= b <= 16)
 *
 * 【输出】
 * 输出一行，表示转换后的 b 进制数。
 * 输出时字母符号全用大写表示 (A, B, ..., F)。
 *
 * 【样例输入】
 * 15 Aab3 7
 *
 * 【样例输出】
 * 210306
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 总体策略：
 * - 将 A 进制字符串 -> 转换为 十进制整数 (int)。
 * - 将 十进制整数 -> 转换为 B 进制字符串。
 *
 * 2. 第一步：A 进制转十进制
 * - ]从字符串的最后一位（最低位）开始向前遍历 。
 * - 每一位的权重初始为 1 (a^0)，每前移一位权重乘以 a 。
 * - 将字符转换为对应的数值：
 * - '0'-'9' -> 0-9
 * - 'a'-'z' -> 10-35 (虽然题目只到16进制，但逻辑通用)
 * - 'A'-'Z' -> 10-35
 * - 累加结果：十进制值 += 数值 * 权重。
 *
 * 3. 第二步：十进制转 B 进制
 * - 使用“除基取余法” (短除法)。
 * - 每次取 `tmp % b` 得到当前位的余数。
 * - 将余数转换为对应的字符（0-9 或 A-F）。
 * - `tmp /= b`，直到 tmp 为 0。
 * - 注意：这样得到的字符顺序是**逆序**的（从低位到高位），输出时需要反向遍历 。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>

int main() {
    int a, b;
    char str[40]; // 存放输入的 a 进制数字符串

    // 1. 输入：a进制，数值字符串，b进制
    if (scanf("%d %s %d", &a, str, &b) != 3) return 1;

    // 2. 将 a 进制字符串转换为十进制整数 tmp
    int tmp = 0;                // 用于存储中间的十进制结果
    int length = strlen(str);   // 字符串长度
    int weight = 1;             // 当前位的权重 (a^0, a^1, ...)

    // 从字符串末尾（最低位）开始向前遍历
    for (int i = length - 1; i >= 0; i--) {
        int x; // 存放当前字符对应的数值

        if (str[i] >= '0' && str[i] <= '9') {
            x = str[i] - '0';
        }
        else if (str[i] >= 'a' && str[i] <= 'z') {
            x = str[i] - 'a' + 10;
        }
        else {
            x = str[i] - 'A' + 10;
        }

        tmp += x * weight; // 累加：数值 * 权重
        weight *= a;       // 更新下一位的权重
    }

    // 3. 将十进制整数 tmp 转换为 b 进制
    char ans[40]; // 存放结果字符
    int size = 0; // 结果长度

    // 特判：如果数值为0，直接输出0（虽然题目说是非负整数，通常包含0）
    if (tmp == 0) {
        printf("0\n");
        return 0;
    }

    // 短除法取余
    while (tmp > 0) {
        int remainder = tmp % b; // 取余数

        // 将余数转换为字符
        if (remainder < 10) {
            ans[size++] = remainder + '0';
        } else {
            ans[size++] = remainder - 10 + 'A'; // 题目要求大写输出
        }

        tmp /= b; // 除以基数
    }

    // 4. 逆序输出结果
    // 因为短除法得到的也是从低位到高位，所以要倒着打印
    for (int i = size - 1; i >= 0; i--) {
        printf("%c", ans[i]);
    }
    printf("\n");

    return 0;
}

/*
 * ======================================================================================
 * 类别：数学问题——素数（质因数分解）
 *
 * 题目：质因数分解
 *
 * 【描述】
 * 编写一个程序，从键盘输入一个正整数 N (2 <= N <= 10^8)。
 * 将 N 表示成质因子的连乘积，并输出。
 * 输出的所有数字按升序排列。
 *
 * 【输入】
 * 输入一个正整数 N。
 *
 * 【输出】
 * 输出质因数分解的形式，格式如：2*2*3*5。
 *
 * 【样例输入】
 * 60
 *
 * 【样例输出】
 * 2*2*3*5
 *
 * 【样例输入2】
 * 123456
 *
 * 【样例输出2】
 * 2*2*2*2*2*2*3*643
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 核心算法：试除法 (Trial Division)
 * - 既然我们要找 N 的质因子，从小到大尝试每一个整数 i (从 2 开始)。
 * - 如果 N 能被 i 整除 (N % i == 0)，说明 i 是 N 的一个因子。
 * - 由于我们是从小到大枚举的，第一个能整除 N 的 i 一定是质数（如果是合数，它一定会被更小的质数分解掉）。
 *
 * 2. 具体步骤：
 * - 循环遍历 i 从 2 开始，直到 i * i <= n。
 * - 这是一个关键优化：如果 n 有因子，一定有一个小于等于 sqrt(n)。
 * - 在循环内部，使用 while (n % i == 0) 不断除以 i：
 * - 每次整除，就打印出 i。
 * - 更新 n = n / i。
 * - 控制格式：如果是第一个输出的因子，直接打印；否则打印 "*i"。
 *
 * 3. 剩余处理：
 * - 循环结束时，如果 n > 1，说明剩下的这个 n 本身就是一个大于 sqrt(原始N) 的质数。
 * - 需要把它也打印出来。
 *
 * 4. 复杂度分析：
 * - 这种方法不需要预先生成素数表，空间复杂度 O(1)。
 * - 时间复杂度最坏情况为 O(sqrt(N))，对于 10^8 的数据量，运算次数在 10000 左右，非常快。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <stdbool.h> // 使用 bool 类型

int main() {
    int n;

    // 1. 输入
    if (scanf("%d", &n) != 1) return 1;

    // 用于标记是否是第一个输出的因子，用于控制 "*" 的打印
    bool first = true;

    // 2. 试除法核心逻辑
    // 从 2 开始枚举，直到 i * i > n
    for (int i = 2; i * i <= n; i++) {
        // 只要 n 能被 i 整除，i 就是一个质因子
        // 使用 while 是因为同一个质因子可能出现多次（如 12 = 2 * 2 * 3）
        while (n % i == 0) {
            if (first) {
                printf("%d", i);
                first = false; // 之后就不是第一个了
            } else {
                printf("*%d", i);
            }
            n /= i; // 除掉这个因子，继续寻找
        }
    }

    // 3. 处理剩余的 n
    // 如果循环结束后 n 仍然大于 1，说明剩下的 n 是一个无法被 sqrt(原始n) 以内的数整除的质数
    if (n > 1) {
        if (first) {
            printf("%d", n);
        } else {
            printf("*%d", n);
        }
    }

    printf("\n"); // 换行

    return 0;
}

/*
 * ======================================================================================
 * 类别：数学问题——素数（往年试题）
 *
 * [cite_start]题目：孪生素数对 [cite: 1189, 1190]
 *
 * 【描述】
 * 差为 2 的两个素数（又称质数）被称为孪生素数对，例如 3 和 5，11 和 13。
 * 编写一个程序，从键盘输入两个正整数 min 和 max (1 <= min < max <= 10^6)。
 * 求解区间 [min, max] 内孪生素数对的个数。
 *
 * 【输入】
 * 输入两个正整数 min 和 max。
 *
 * 【输出】
 * 输出一个整数，表示区间内孪生素数对的个数。
 *
 * 【样例输入】
 * 2 15
 *
 * 【样例输出】
 * 3
 * (解释：在区间[2, 15]内的孪生素数对有：(3, 5), (5, 7), (11, 13)。注意 7 和 11 差为 4，不是孪生素数对。)
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 算法选择：埃氏筛法 (Sieve of Eratosthenes)
 * - 题目要求的 max 可达 10^6。如果我们对每个数都写一个 `check_prime` 函数去判断，时间复杂度会较高。
 * - 更好的方式是开一个布尔数组 `is_prime[]`，先筛出 1 到 1,000,000 之间的所有素数。
 *
 * 2. 筛法步骤：
 * - 初始化一个大小为 1000005 的数组，假设所有数都是素数（标记为 1）。
 * - 0 和 1 不是素数，先标记为 0。
 * - 从 2 开始遍历，如果当前数 i 是素数，则将它的所有倍数 (2*i, 3*i, ...) 标记为非素数。
 * - 遍历到 sqrt(max) 即可停止筛选。
 *
 * 3. 统计逻辑：
 * - 题目要求统计“区间 [min, max] 内”的孪生素数对。
 * - 一对孪生素数 (i, i+2) 必须满足两个条件：
 * 1. i 和 i+2 都是素数。
 * 2. 都在区间内： i >= min 且 i+2 <= max。
 * - 因此，我们只需遍历 i 从 min 到 max-2。
 * - 如果 `is_prime[i]` 和 `is_prime[i+2]` 均为真，则计数器加 1。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <stdbool.h>
#include <string.h>

// 定义最大范围，稍微大一点防止越界
#define MAX_N 1000005

// 标记数组：is_prime[i] = true 表示 i 是素数
// 定义为全局变量，避免在 main 函数栈中占用过多内存导致溢出
bool is_prime[MAX_N];

// 埃氏筛法预处理
void sieve(int n) {
    // 1. 初始化：假设全是素数
    // memset 将内存块设置为特定值，这里用 true (1) 或 false (0) 都可以，C语言中 true通常非0
    // 为了简单，我们手动循环或者用 memset(is_prime, 1, sizeof(is_prime)) (依赖stdbool实现)
    // 这里使用循环初始化更通用
    for (int i = 0; i <= n; i++) {
        is_prime[i] = true;
    }

    // 2. 特殊处理 0 和 1
    is_prime[0] = false;
    is_prime[1] = false;

    // 3. 筛选
    for (int i = 2; i * i <= n; i++) {
        if (is_prime[i]) {
            // 如果 i 是素数，将 i 的倍数全部标记为非素数
            // 从 i*i 开始即可，因为小于 i*i 的倍数已经被更小的素数筛过了
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
}

int main() {
    // 1. 预处理素数表 (最大到 10^6)
    sieve(1000000);

    int min, max;
    // 2. 输入
    if (scanf("%d %d", &min, &max) != 2) return 1;

    int count = 0;

    // 3. 遍历区间统计
    // 我们要找 (i, i+2)，保证两个数都在 [min, max] 范围内
    // 所以 i 的范围是 [min, max-2]
    // 还需要防止 max < 2 的情况导致循环条件出错（虽然题目保证 min>=1, max>=min）
    if (max >= 2) {
        for (int i = min; i <= max - 2; i++) {
            // 如果 i 和 i+2 都是素数
            if (is_prime[i] && is_prime[i + 2]) {
                count++;
                // 调试输出（可选）
                // printf("Found pair: %d, %d\n", i, i+2);
            }
        }
    }

    // 4. 输出结果
    printf("%d\n", count);

    return 0;
}

/*
 * ======================================================================================
 * 类别：数据结构——链表模拟
 *
 * 题目：扑克牌堆
 *
 * 【描述】
 * 扑克牌有4种花色：黑桃(Spade)、红心(Heart)、梅花(Club)、方块(Diamond)。
 * 每种花色有13张牌，编号为：A, 2, 3, ..., 10, J, Q, K。
 * 初始时牌堆为空。定义以下4种操作：
 * 1) Append [花色] [编号]：添加一张牌到牌堆底部。
 * 2) Extract [花色]：抽取该花色的所有牌，按编号从小到大排序，放到牌堆顶部。
 * 3) Revert：将整个牌堆逆序。
 * 4) Pop：丢弃牌堆顶部的第一张牌（如果非空）。
 *
 * 【输入】
 * 第一行：操作数量 n (1 <= n <= 1000)。
 * 接下来 n 行：每行一个操作命令。
 *
 * 【输出】
 * 输出最终牌堆顶部的牌（花色和编号）。如果为空，输出 "null"。
 *
 * 【样例输入】
 * 6
 * Append Club Q
 * Append Diamond 5
 * Append Club 10
 * Extract Club
 * Revert
 * Pop
 *
 * 【样例输出】
 * Club Q
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据结构设计：
 * - 定义 `struct card`，包含 `color` (字符串), `number` (字符串), `next` (指针)。
 * - 使用单链表来维护牌堆，`head` 指向牌堆顶部。
 *
 * 2. 核心操作实现：
 * - **Append (尾插法)**：遍历链表找到最后一个节点，将其 `next` 指向新节点。如果链表为空，直接让 `head` 指向新节点。
 * - **Pop (头删法)**：`head = head->next`，并释放原头节点的内存（考试时如果内存不严苛，不free通常也不判错，但好习惯是free）。
 * - **Revert (链表反转)**：经典算法。遍历链表，将每个节点的 `next` 指向前一个节点。需要三个指针 `prev`, `curr`, `next` 配合。
 * - **Extract (抽取并排序)**：这是最复杂的一步。
 * a. 遍历链表，把匹配花色的节点“摘”出来，组成一个新的链表 `extractList`。
 * b. 没被摘走的节点保留在原链表中。
 * c. 对 `extractList` 进行排序（可以使用冒泡排序交换节点内容，或者重新链接）。
 * d. 将排序后的 `extractList` 拼接到原链表的头部（因为题目要求放到顶部）。
 *
 * 3. 辅助函数：
 * - `numberToInt`: 将 A, J, Q, K 转换为 1, 11, 12, 13 以便比较大小。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 定义扑克牌节点结构
typedef struct card {
    char color[10];
    char number[5];
    struct card* next;
} card;

// 辅助函数：将牌面字符转换为数字，便于比较
int numberToInt(char number[]) {
    if (strcmp(number, "A") == 0) return 1;
    if (strcmp(number, "10") == 0) return 10;
    if (strcmp(number, "J") == 0) return 11;
    if (strcmp(number, "Q") == 0) return 12;
    if (strcmp(number, "K") == 0) return 13;
    return number[0] - '0'; // 2-9
}

// 比较两张牌的大小
int compare(card* c1, card* c2) {
    return numberToInt(c1->number) - numberToInt(c2->number);
}

// 操作1：Append - 添加牌到队尾
card* appendcard(card* head, char color[], char number[]) {
    // 创建新节点
    card* newcard = (card*)malloc(sizeof(card));
    strcpy(newcard->color, color);
    strcpy(newcard->number, number);
    newcard->next = NULL;

    if (head == NULL) {
        return newcard;
    } else {
        card* p = head;
        // 找到尾部
        while (p->next != NULL) {
            p = p->next;
        }
        p->next = newcard;
        return head;
    }
}

// 操作4：Pop - 丢弃堆顶牌
card* popcard(card* head) {
    if (head == NULL) return NULL;
    card* temp = head;
    head = head->next;
    free(temp); // 释放内存
    return head;
}

// 操作3：Revert - 链表反转
card* revertcard(card* head) {
    card* prev = NULL;
    card* current = head;
    card* next = NULL;
    
    while (current != NULL) {
        next = current->next; // 保存下一个节点
        current->next = prev; // 反转指针
        prev = current;       // 步进
        current = next;
    }
    return prev; // prev 变成了新的头
}

// 辅助：链表长度
int list_length(card* head) {
    int n = 0;
    while (head != NULL) {
        n++;
        head = head->next;
    }
    return n;
}

// 辅助：对链表进行排序（这里使用简化的冒泡排序，交换节点内容）
void sortcard(card* head) {
    if (head == NULL || head->next == NULL) return;
    
    int n = list_length(head);
    for (int i = 0; i < n - 1; i++) {
        card* p = head;
        for (int j = 0; j < n - 1 - i; j++) {
            if (compare(p, p->next) > 0) {
                // 交换内容（数据量小，交换内容比交换指针简单）
                char tempColor[10], tempNum[5];
                
                strcpy(tempColor, p->color);
                strcpy(tempNum, p->number);
                
                strcpy(p->color, p->next->color);
                strcpy(p->number, p->next->number);
                
                strcpy(p->next->color, tempColor);
                strcpy(p->next->number, tempNum);
            }
            p = p->next;
        }
    }
}

// 操作2：Extract - 抽取特定花色，排序后放回顶部
card* extractcard(card* head, char color[]) {
    card* extractedList = NULL; // 存放抽出来的牌
    card* remainingList = NULL; // 存放剩下的牌
    card* p = head;

    // 1. 分离链表
    while (p != NULL) {
        card* nextNode = p->next; // 先保存下一个，因为我们要断开链接
        
        if (strcmp(p->color, color) == 0) {
            // 匹配：加入 extractedList 尾部
            // 注意：为了简单，这里可以直接利用 appendcard 函数创建新节点，
            // 或者手动维护指针。PPT中使用的是手动维护。
            // 这里为了代码复用，演示 appendcard 逻辑，但需注意原 p 节点需要释放或复用
            // 为保持简单清晰，我们复用节点：
            
            p->next = NULL; // 断开
            if (extractedList == NULL) {
                extractedList = p;
            } else {
                // 找到 extractedList 尾部接上
                card* temp = extractedList;
                while (temp->next != NULL) temp = temp->next;
                temp->next = p;
            }
        } else {
            // 不匹配：加入 remainingList 尾部
            p->next = NULL;
            if (remainingList == NULL) {
                remainingList = p;
            } else {
                card* temp = remainingList;
                while (temp->next != NULL) temp = temp->next;
                temp->next = p;
            }
        }
        p = nextNode;
    }

    // 2. 对抽取的牌排序
    sortcard(extractedList);

    // 3. 拼接：extractedList 在前，remainingList 在后
    if (extractedList == NULL) return remainingList;
    
    card* temp = extractedList;
    while (temp->next != NULL) temp = temp->next; // 找到extracted的尾部
    temp->next = remainingList; // 接上剩余的
    
    return extractedList;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 0;
    
    card* head = NULL;
    char op[20], color[10], num[5];

    for (int i = 0; i < n; i++) {
        scanf("%s", op);
        if (strcmp(op, "Append") == 0) {
            scanf("%s %s", color, num);
            head = appendcard(head, color, num);
        } else if (strcmp(op, "Extract") == 0) {
            scanf("%s", color);
            head = extractcard(head, color);
        } else if (strcmp(op, "Revert") == 0) {
            head = revertcard(head);
        } else if (strcmp(op, "Pop") == 0) {
            head = popcard(head);
        }
    }

    // 输出结果
    if (head == NULL) {
        printf("null\n");
    } else {
        printf("%s %s\n", head->color, head->number);
    }

    return 0;
}

/*
 * ======================================================================================
 * 类别：数学问题——离散数学逻辑推理
 *
 * 题目：谁去了紫荆
 *
 * 【描述】
 * 徐老师发现有4个学生 A、B、C、D 中有 1 个人去了紫荆食堂，其他人去了桃李食堂。
 * 徐老师想知道是谁去了紫荆。
 * 四位学生分别给了徐老师一句回答（回答中的 X、Y、Z、Q 为输入变量，代表 A,B,C,D 中的某一个）：
 * - 学生 A 说: X 去了紫荆。
 * - 学生 B 说: Y 没去紫荆。
 * - 学生 C 说: Z 去了紫荆。
 * - 学生 D 说: Q 没去紫荆。
 *
 * 已知：这 4 个人中，有且仅有 2 个人说了真话，另外 2 个人说了假话。
 * 请找出谁去了紫荆。如果有多个可能的人，请按字典序输出所有可能的人。
 *
 * 【输入】
 * 输入一行包含 4 个字符（X, Y, Z, Q），中间用空格隔开。
 * 它们分别代表 A, B, C, D 四句话中提到的那个人。
 *
 * 【输出】
 * 输出一行，包含所有满足条件的人的编号（A/B/C/D），直接拼接输出。
 *
 * 【样例输入】
 * A A C C
 *
 * 【样例输出】
 * ABCD
 *
 * 【样例解释】
 * 假设 X=A, Y=A, Z=C, Q=C。
 * - 如果 A 去紫荆：
 * A说(A去)真，B说(A没去)假，C说(C去)假，D说(C没去)真 -> 2真2假 -> A是答案。
 * - 如果 B 去紫荆：
 * A说(A去)假，B说(A没去)真，C说(C去)假，D说(C没去)真 -> 2真2假 -> B是答案。
 * ...以此类推，本样例中ABCD都符合条件。
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 核心思想：枚举 (Enumeration)
 * - 我们不知道谁去了紫荆，但只有 4 种可能：A, B, C, 或 D。
 * - 我们可以写一个循环 `char person = 'A'; person <= 'D'; person++`，依次假设某个人去了紫荆。
 *
 * 2. 逻辑验证：
 * - 在假设 `person` 去了紫荆的情况下，我们需要判断 A, B, C, D 四个人的话是真还是假。
 * - 只要判断每句话的逻辑条件是否成立即可（成立则 judge++）。
 *
 * 3. 语句分析：
 * - 输入的四个字符变量分别为 x, y, z, q。
 * - A的话：“x 去了紫荆”。 真值条件：(person == x)
 * - B的话：“y 没去紫荆”。 真值条件：(person != y)
 * - C的话：“z 去了紫荆”。 真值条件：(person == z)
 * - D的话：“q 没去紫荆”。 真值条件：(person != q)
 *
 * 4. 统计与输出：
 * - 统计这 4 句话中真话的数量 `judge`。
 * - 如果 `judge == 2`，说明假设成立，输出当前的 `person`。
 *
 * ======================================================================================
 */

#include <stdio.h>

int main() {
    char x, y, z, q;

    // 1. 输入部分
    // 注意：scanf读取字符时会读取空格，所以格式串中加入空格 " %c" 可以跳过前面的空白符
    // 或者直接 "%c %c %c %c" 只要输入标准也没问题，但加空格更稳健
    if (scanf(" %c %c %c %c", &x, &y, &z, &q) != 4) return 0;

    // 2. 枚举所有可能去紫荆的人 (person)
    // 从 A 遍历到 D
    for (char person = 'A'; person <= 'D'; person++) {
        int true_count = 0; // 记录说真话的人数

        // 3. 判断四句话的真假

        // A说: X 去了紫荆
        // 如果当前假设的 person 就是 X，那么A说的是真话
        if (person == x) true_count++;

        // B说: Y 没去紫荆
        // 如果当前假设的 person 不是 Y，那么B说的是真话
        if (person != y) true_count++;

        // C说: Z 去了紫荆
        // 如果当前假设的 person 就是 Z，那么C说的是真话
        if (person == z) true_count++;

        // D说: Q 没去紫荆
        // 如果当前假设的 person 不是 Q，那么D说的是真话
        if (person != q) true_count++;

        // 4. 检查是否满足“2真2假”的条件
        if (true_count == 2) {
            printf("%c", person);
        }
    }
    
    printf("\n"); // 结尾换行

    return 0;
}
namespace doulist{ 
/*
 * ======================================================================================
 * 类别：数据结构——双向循环链表（往年试题）
 *
 * 题目：环形网络
 *
 * 【描述】
 * 构建一个环形网络，包含多个网络节点。每个节点有两个属性：
 * 1. 网络标识 (ID)：由6个小写字母组成，唯一。
 * 2. 传输延迟 (Delay)：一个正整数。
 * 初始时网络为空。定义以下 5 种操作：
 * 1) Append [delay] [id]：
 * - 如果网络为空，添加一个节点并作为“接入点(Entry)”。
 * - 否则，在当前接入点的“逆时针”方向添加一个相邻节点，接入点位置不变。
 * (注：即插入到 entry->prev 和 entry 之间)
 * 2) Eliminate [m] [n]：
 * - 从接入点开始顺时针计数，每数到第 m 个节点就将其删除。
 * - 然后从下一个节点重新计数，直到删除了 n 个节点为止。
 * - 若删除的节点是接入点，则顺时针方向的下一个节点成为新的接入点。
 * 3) Move [0/1] [r]：
 * - 0 表示接入点顺时针移动 r 个节点。
 * - 1 表示接入点逆时针移动 r 个节点。
 * 4) Sort：
 * - 将网络中节点按“传输延迟”从小到大排序；若延迟相同，按 ID 字典序排列。
 * - 排序后，接入点仍然指向排序前指向的那个节点（即使该节点的位置变了）。
 * 5) Delete [id]：
 * - 删除指定 ID 的节点。
 * - 若删除的是接入点，顺时针下一个节点成为新接入点。
 * - 若节点不存在，不进行操作；若删除后网络为空，接入点置空。
 *
 * 【输入】
 * 第一行：整数 T (1 <= T <= 1000)，表示命令数量。
 * 接下来 T 行，每行一个命令。
 * 最后一行：一个网络标识 id，表示需要查询的目标节点。
 *
 * 【输出】
 * - 如果网络为空或目标节点不存在，输出 "-1"。
 * - 如果目标节点就是接入点，输出 "0"。
 * - 否则，按顺序输出从接入点到目标节点之间（含接入点，不含目标点）经过的所有节点的 ID（每行一个）。
 * 最后输出这些节点的传输延迟之和。
 *
 * 【样例输入】
 * 8
 * Append 1 nameaa
 * Append 3 bbbbbb
 * Append 5 aabbcc
 * Append 4 abcdef
 * Sort
 * Eliminate 2 1
 * Move 0 1
 * Delete nameaa
 * aabbcc
 *
 * 【样例输出】
 * abcdef
 * 4
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据结构：
 * - 使用双向循环链表 (Circular Doubly Linked List)。
 * - 节点结构包含：`id`, `delay`, `prev`, `next`。
 * - 全局变量 `entry` 指向当前的接入点。
 *
 * 2. 操作实现细节：
 * - **Append**:
 * - 若链表为空：`entry = new_node`, `next=self`, `prev=self`。
 * - 否则：插入到 `entry` 和 `entry->prev` 之间。
 * - **Eliminate**:
 * - 循环 n 次执行删除逻辑。
 * - 每次循环：从 `entry` 开始向 `next` 方向走 m-1 步找到目标。
 * - 删除目标节点。注意更新 `entry` 指针（如果删的是 `entry`，`entry = target->next`）。
 * - **Move**:
 * - 根据方向 (0或1) 移动 `entry` 指针 r 次。
 * - **Sort**:
 * - 这是难点。因为是环形链表，直接排序比较麻烦。
 * - 策略：先断开环，把所有节点放入一个数组（或线性链表）。
 * - 对数组使用 `qsort` 进行排序。
 * - 重新连接数组中的节点形成新的环。
 * - **关键**：排序前记录 `entry` 指向的节点地址，排序后 `entry` 依然指向该地址。
 * - **Delete**:
 * - 遍历链表查找 ID。找到后执行标准双向链表删除。
 *
 * 3. 查询与输出：
 * - 遍历链表查找目标 ID。
 * - 找到了：
 * - 若 `target == entry`，输出 0。
 * - 否则，从 `entry` 开始顺时针遍历，打印 ID 并累加 delay，直到遇到 `target` 停止。
 * - 输出总 delay。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char id[10];
    int delay;
    struct Node *prev;
    struct Node *next;
} Node;

Node *entry = NULL; // 全局接入点
int count = 0;      // 链表节点数量，维护这个变量有助于处理空表和排序

// 创建新节点
Node* createNode(int delay, char *id) {
    Node *p = (Node*)malloc(sizeof(Node));
    p->delay = delay;
    strcpy(p->id, id);
    p->prev = p->next = p;
    return p;
}

// 查找节点
Node* findNode(char *id) {
    if (entry == NULL) return NULL;
    Node *p = entry;
    do {
        if (strcmp(p->id, id) == 0) return p;
        p = p->next;
    } while (p != entry);
    return NULL;
}

// 从链表中移除节点（不释放内存，用于重新排序或删除）
void unlinkNode(Node *p) {
    if (count == 1) {
        entry = NULL;
    } else {
        p->prev->next = p->next;
        p->next->prev = p->prev;
        if (entry == p) entry = p->next; // 如果移除的是接入点，顺移
    }
    count--;
}

// 释放节点内存
void deleteNode(Node *p) {
    unlinkNode(p);
    free(p);
}

// Append操作
void append(int delay, char *id) {
    Node *new_node = createNode(delay, id);
    if (entry == NULL) {
        entry = new_node;
    } else {
        // 插入到 entry 的逆时针方向 (即 entry->prev 和 entry 之间)
        Node *tail = entry->prev;
        tail->next = new_node;
        new_node->prev = tail;
        new_node->next = entry;
        entry->prev = new_node;
    }
    count++;
}

// Eliminate操作
void eliminate(int m, int n) {
    if (entry == NULL) return;
    for (int i = 0; i < n; i++) {
        if (entry == NULL) break;
        Node *target = entry;
        // 顺时针数 m 个节点（包括自己，所以走 m-1 步）
        for (int j = 0; j < m - 1; j++) {
            target = target->next;
        }
        // 删除 target，如果 target 是 entry，unlinkNode 会自动更新 entry
        // 但我们需要确保下一次计数是从“下一个”开始，unlinkNode 逻辑已涵盖
        Node *next_start = target->next; 
        
        // 特殊处理：如果删除了节点，且该节点不是 entry，entry 不变
        // 如果删除了 entry，unlinkNode 会把 entry 指向 next
        // 题目要求：若删除的为接入点，顺时针下一个为接入点。
        // 如果删除的不是接入点，题目说“由下一个节点重新计数”。
        // 为了统一逻辑，我们可以临时把 entry 设为 target 的下一个，以便下一轮循环正确开始
        
        // 简单处理：先记录由于删除操作可能导致的新起点
        // 其实 unlinkNode 内部的 entry 更新逻辑只处理了 entry 被删的情况
        // 对于 Eliminate，每一轮删除后，计数起点都要变更为被删节点的下一个
        
        // 备份一下当前的 entry，因为 unlink 可能会改它
        int is_entry = (target == entry);
        unlinkNode(target); 
        free(target);
        
        if (count == 0) {
            entry = NULL;
            break;
        }
        
        // 无论删的是谁，下一轮都要从被删节点的下一个开始数
        // 如果删的是 entry，unlink 已经把 entry 更新为 next 了，所以不用动
        // 如果删的不是 entry，我们需要手动把 entry 挪到 next_start，
        // 因为题目说“由下一个节点重新计数”，隐含的意思是下一个计数操作的“当前点”变了
        // 在本题逻辑中，计数总是从 entry 开始，所以我们需要更新 entry
        if (!is_entry) {
            entry = next_start;
        }
    }
}

// Sort 比较函数
int cmp(const void *a, const void *b) {
    Node *n1 = *(Node**)a;
    Node *n2 = *(Node**)b;
    if (n1->delay != n2->delay) {
        return n1->delay - n2->delay;
    }
    return strcmp(n1->id, n2->id);
}

// Sort操作
void sortList() {
    if (count < 2) return;
    
    // 1. 将所有节点指针存入数组
    Node **arr = (Node**)malloc(count * sizeof(Node*));
    Node *p = entry;
    for (int i = 0; i < count; i++) {
        arr[i] = p;
        p = p->next;
    }
    
    // 2. 排序
    qsort(arr, count, sizeof(Node*), cmp);
    
    // 3. 重新连接
    for (int i = 0; i < count; i++) {
        arr[i]->next = arr[(i + 1) % count];
        arr[i]->prev = arr[(i - 1 + count) % count];
    }
    // entry 指针本身不需要改，它指向的节点地址没变，只是那个节点的 prev/next 变了
    // 题目要求“接入点仍指向排序前的网络节点”，所以 entry 变量保持不变即可
    
    free(arr);
}

int main() {
    int T;
    if (scanf("%d", &T) != 1) return 0;
    
    char cmd[20];
    for (int i = 0; i < T; i++) {
        scanf("%s", cmd);
        if (strcmp(cmd, "Append") == 0) {
            int d; char s[10];
            scanf("%d %s", &d, s);
            append(d, s);
        } else if (strcmp(cmd, "Eliminate") == 0) {
            int m, n;
            scanf("%d %d", &m, &n);
            eliminate(m, n);
        } else if (strcmp(cmd, "Move") == 0) {
            int dir, r;
            scanf("%d %d", &dir, &r);
            if (entry && count > 0) {
                r %= count; // 优化：取模
                for (int k = 0; k < r; k++) {
                    if (dir == 0) entry = entry->next; // 顺时针
                    else entry = entry->prev;          // 逆时针
                }
            }
        } else if (strcmp(cmd, "Sort") == 0) {
            sortList();
        } else if (strcmp(cmd, "Delete") == 0) {
            char s[10];
            scanf("%s", s);
            Node *target = findNode(s);
            if (target) deleteNode(target);
        }
    }
    
    // 查询
    char query_id[10];
    scanf("%s", query_id);
    
    Node *target = findNode(query_id);
    
    if (target == NULL) {
        printf("-1\n");
    } else if (target == entry) {
        printf("0\n");
    } else {
        // 输出从 entry 到 target 之前的路径（顺时针）
        long long total_delay = 0;
        Node *p = entry;
        while (p != target) {
            printf("%s\n", p->id);
            total_delay += p->delay;
            p = p->next;
        }
        printf("%lld\n", total_delay);
    }
    
    return 0;
}
}
/*
 * ======================================================================================
 * 类别：动态规划 (Dynamic Programming) —— 基础递推
 *
 * 题目：N阶楼梯上楼问题
 *
 * 【描述】
 * N阶楼梯上楼问题：一次可以走两阶或者一阶，问有多少种上楼方式？
 * 要求使用非递归方式求解。
 *
 * 【输入】
 * 输入包括一个正整数 N (1 <= N <= 90)。
 *
 * 【输出】
 * 输出当楼梯阶数是 N 时，上楼方式的总个数。
 *
 * 【样例输入】
 * 4
 *
 * 【样例输出】
 * 5
 *
 * 【样例解释】
 * 4阶楼梯的走法有5种：
 * 1. 1->1->1->1
 * 2. 1->1->2
 * 3. 1->2->1
 * 4. 2->1->1
 * 5. 2->2
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 状态定义：
 * - 设 F[n] 为走到第 n 阶楼梯的方法总数。
 *
 * 2. 递推公式分析：
 * - 想要到达第 n 阶（n > 2），最后一步只有两种可能：
 * a. 从第 n-1 阶迈 1 步上来。此时的方法数等于到达 n-1 阶的方法数，即 F[n-1]。
 * b. 从第 n-2 阶迈 2 步上来。此时的方法数等于到达 n-2 阶的方法数，即 F[n-2]。
 * - 因此，到达第 n 阶的总方法数 F[n] = F[n-1] + F[n-2]。
 *
 * 3. 初始条件：
 * - 1阶楼梯：只能走1步。 F[1] = 1。
 * - 2阶楼梯：可以 "1+1" 或 "2"。 F[2] = 2。
 *
 * 4. 数据类型选择：
 * - 题目给出的 N 最大为 90。
 * - 斐波那契数列增长极快，F[46] 左右就会超过 int (2^31 - 1) 的范围。
 * - F[90] 是一个非常大的数（约 2.88 * 10^18），必须使用 `long long` 类型来存储。
 * - 打印时使用 `%lld` 格式符。
 *
 * ======================================================================================
 */

#include <stdio.h>

int main() {
    int n;
    
    // 定义数组用于存储结果
    // N 最大为 90，索引需要到 90，所以大小设为 91 或更大
    // 必须使用 long long 防止溢出
    long long F[95];

    // 1. 初始化边界值
    F[1] = 1;
    F[2] = 2;

    // 2. 递推计算 (预处理)
    // 我们可以先算出所有结果，也可以读入 n 后再算。
    // 这里采用预先计算到 90 的方式，这样如果有多次查询会更快（虽然本题只输入一次）。
    for (int i = 3; i <= 90; i++) {
        F[i] = F[i - 1] + F[i - 2];
    }

    // 3. 输入 N
    if (scanf("%d", &n) != 1) return 1;

    // 4. 输出结果
    // 根据题目描述，1 <= N <= 90。
    // 如果 n=1 或 n=2，直接输出对应初始值；如果 n>2，输出计算结果。
    // 由于我们已经从 F[1] 初始化到了 F[90]，直接输出 F[n] 即可。
    printf("%lld\n", F[n]);

    return 0;
}

/*
 * ======================================================================================
 * 类别：动态规划 (Dynamic Programming) —— 线性DP
 *
 * 题目：拦截导弹
 *
 * 【描述】
 * 某国为了防御敌国的导弹袭击，开发出了一套导弹拦截系统。
 * 系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。
 * 某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度。
 * 请计算这套系统最多能拦截多少导弹。
 * 拦截时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。
 *
 * 【输入】
 * 第一行：输入雷达捕捉到的敌国导弹数量 k (k <= 25)。
 * 第二行：输入 k 个正整数，表示 k 枚导弹的高度，按袭击时间顺序给出，以空格分隔。
 *
 * 【输出】
 * 输出一个整数，表示最多能拦截多少枚导弹。
 *
 * 【样例输入】
 * 8
 * 300 207 155 300 299 170 158 65
 *
 * 【样例输出】
 * 6
 *
 * 【样例解释】
 * 一种可能的拦截序列是：300, 299, 170, 158, 65 (共5个？不对，题目样例输出是6)
 * 让我们仔细看样例：300(第1个), 300(第4个), 299, 170, 158, 65 -> 共6个。
 * 或者：300(第1个), 207, 155, ... 这样只能接更小的。
 * 关键在于第4个导弹高度又是300，它可以接在第1个300后面（因为300 <= 300）。
 * 所以最优解可能是：300 -> 300 -> 299 -> 170 -> 158 -> 65。
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 问题建模：
 * - 给定一个序列 A，求其最长不增子序列的长度。
 * - 子序列要求下标严格递增 (i < j)，且数值满足 A[i] >= A[j]。
 *
 * 2. 状态定义：
 * - 定义 dp[i] 为 **以第 i 枚导弹结尾** 的最长不增子序列的长度。
 *
 * 3. 状态转移方程：
 * - 对于每一个 i (1 <= i <= k)，我们遍历它前面的所有 j (1 <= j < i)。
 * - 如果 A[j] >= A[i]（即前面的导弹高度不低于当前导弹，满足拦截条件）：
 * 说明第 i 枚导弹可以接在第 j 枚导弹后面。
 * 此时，以 i 结尾的序列长度可以是 dp[j] + 1。
 * - 我们在所有满足条件的 j 中，找一个让 dp[j] 最大的，更新 dp[i]。
 * - 方程：dp[i] = max(1, dp[j] + 1)   其中 1 <= j < i 且 A[j] >= A[i]。
 * - 初始值：dp[i] 至少为 1（只拦截它自己）。
 *
 * 4. 最终结果：
 * - 答案不是 dp[k]，而是 dp 数组中的最大值（因为最长序列可能以任意位置结束）。
 *
 * ======================================================================================
 */

#include <stdio.h>

// 辅助函数：求最大值
int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int n;           // 导弹数量
    int list[30];    // 存储导弹高度 (题目 k<=25，开30足够)
    int dp[30];      // dp[i] 存储以第 i 个导弹结尾的最长不增子序列长度

    // 1. 输入
    if (scanf("%d", &n) != 1) return 1;

    for (int i = 0; i < n; i++) {
        scanf("%d", &list[i]);
    }

    // 2. 动态规划过程
    for (int i = 0; i < n; i++) {
        // 初始化：每个导弹至少可以拦截自己，长度为1
        int tmax = 1;

        // 遍历 i 之前的所有导弹 j
        for (int j = 0; j < i; j++) {
            // 如果前面的导弹 j 高度 >= 当前导弹 i 高度
            // 说明 i 可以接在 j 后面
            if (list[j] >= list[i]) {
                // 更新当前能达到的最大长度
                tmax = max(tmax, dp[j] + 1);
            }
        }
        
        // 将计算出的最大长度存入 dp[i]
        dp[i] = tmax;
    }

    // 3. 寻找结果
    // 遍历 dp 数组，找出最大值
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, dp[i]);
    }

    // 4. 输出
    printf("%d\n", ans);

    return 0;
}

/*
 * ======================================================================================
 * 类别：动态规划 (Dynamic Programming) —— 线性DP
 *
 * 题目：最长公共子串 (实际逻辑为：最长公共子序列 LCS)
 *
 * 【描述】
 * 有两个字符串 S1 和 S2，求一个最长公共子串，即求字符串 S3，它同时为 S1 和 S2 的子串，
 * 且要求它的长度最长，并确定这个长度。
 * (注意：根据考题代码逻辑，这里的“子串”定义允许字符不连续，即标准的“子序列”定义)
 *
 * 【输入】
 * 输入有两行，每行包含一个由小写字母组成的字符串。
 * 其中每个字符串中不含空格，且长度不超过 100。
 *
 * 【输出】
 * 包含一个整数，表示两个字符串的最长公共子串的长度。
 *
 * 【样例输入】
 * abcd
 * cxbydz
 *
 * 【样例输出】
 * 2
 * (解释：公共部分为 "bd"，长度为2。如果是连续子串，答案应为1，如"b"或"d"。)
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 状态定义：
 * - dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符形成的最长公共子串(子序列)的长度。
 *
 * 2. 状态转移方程：
 * - 此时比较 S1 的第 i 个字符 (S1[i-1]) 和 S2 的第 j 个字符 (S2[j-1])。
 * - 情况 1：如果两个字符相等 (S1[i-1] == S2[j-1])：
 * 该字符可以作为公共子串的一部分，接在之前的公共子串后面。
 * dp[i][j] = dp[i-1][j-1] + 1;
 * - 情况 2：如果两个字符不相等 (S1[i-1] != S2[j-1])：
 * 说明这两个字符不能同时出现在当前的最长公共子串末尾。
 * 此时最长长度继承自“S1少看一个字符”或“S2少看一个字符”中的较大者。
 * dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
 *
 * 3. 初始条件：
 * - dp[i][0] = 0 (S2为空，公共长度为0)
 * - dp[0][j] = 0 (S1为空，公共长度为0)
 *
 * 4. 复杂度：
 * - 时间复杂度：O(L1 * L2)
 * - 空间复杂度：O(L1 * L2)
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>

// 定义最大长度，题目要求不超过100，开101足够
// dp数组放在全局区，避免栈溢出（虽然100*100不大，但养成好习惯）
int dp[105][105];

// 辅助函数：求最大值
int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    char S1[105], S2[105];

    // 1. 输入两个字符串
    // 题目保证不含空格，可以用 scanf("%s")
    if (scanf("%s %s", S1, S2) != 2) return 1;

    int L1 = strlen(S1);
    int L2 = strlen(S2);

    // 2. 初始化边界
    // 全局变量默认为0，但为了逻辑严谨显式初始化
    for (int i = 0; i <= L1; i++) dp[i][0] = 0;
    for (int j = 0; j <= L2; j++) dp[0][j] = 0;

    // 3. 动态规划填表
    for (int i = 1; i <= L1; i++) {
        for (int j = 1; j <= L2; j++) {
            // 注意：字符串下标从0开始，dp下标从1开始
            // 所以比较的是 S1[i-1] 和 S2[j-1]
            if (S1[i - 1] == S2[j - 1]) {
                // 字符相同，长度加1
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                // 字符不同，取继承下来的最大值
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // 4. 输出结果
    // dp[L1][L2] 即为最终答案
    printf("%d\n", dp[L1][L2]);

    return 0;
}

/*
 * ======================================================================================
 * 类别：动态规划 (Dynamic Programming) —— 往年真题
 *
 * 题目：短棒拼接（双节棍）
 *
 * 【描述】
 * 有 N 种类型的短棒，第 i 种短棒长度为 a[i]，武力值为 b[i]，数量无限。
 * 这些短棒可以多个粘到一起成为长一些的棒。
 * 拼接规则：
 * 1. 普通情况：长度为 A 的棒和长度为 B 的棒组成一个长度为 A+B 的棒。
 * 此时武力值 = A的武力值 + B的武力值。
 * 2. 特殊情况：如果 A 与 B 的长度相等（A == B），则拼接后的武力值额外增加 233。
 * 即：长度为 2A 的棒武力值 = A的武力值 * 2 + 233。
 *
 * 现在，已知需要一根长 M 的棒，且要求武力值最大化。
 * 请问这根棒最大的武力值是多少？
 *
 * 【输入】
 * 第一行：两个整数 N, M (0 < N, M < 1000)。
 * 第二行：N 个整数，表示每种短棒的长度 a[i]。
 * 第三行：N 个整数，表示每种短棒的武力值 b[i]。
 * (保证有解，即 M 一定能由若干短棒拼成)
 *
 * 【输出】
 * 输出一个整数，表示长度为 M 的棒的最大武力值。
 *
 * 【样例输入】
 * 3 10
 * 1 2 3
 * 1000 3000 6000
 *
 * 【样例输出】
 * 19233
 *
 * 【样例解释】
 * 几种方案对比：
 * 1. 1+3 拼成 4，3+3 拼成 6，然后 4+6 拼成 10 (无特殊加成)。
 * 2. 1+3 -> 4, 3+3 -> 6 (这里的3+3触发+233), 4+6 -> 10.
 * 3. 最佳方案涉及多次触发相等加成：
 * - 3 和 3 拼成 6：武力 = 6000 + 6000 + 233 = 12233
 * - 1 和 3 拼成 4：武力 = 1000 + 6000 = 7000
 * - 4 和 6 拼成 10：武力 = 7000 + 12233 = 19233
 * (注意：可能有更优的拆分，比如 5+5，而 5 又由 2+3 拼成等。
 * 本题样例输出 19233 其实对应的是 (1+3拼成4) 和 (3+3拼成6) 再拼成10，
 * 其中3+3触发了奖励。或者其他组合，通过DP自动寻找最优解。)
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 状态定义：
 * dp[len] 表示长度为 len 的棒所能达到的最大武力值。
 *
 * 2. 初始化：
 * - 将 dp 数组初始化为一个较小的值（如负无穷或0，本题武力值均为正，初始化0即可，但要注意有些长度可能无法组成，不过题目保证有解）。
 * - 根据输入的 N 种基础短棒，初始化 dp 数组。
 * 对于每种基础棒：dp[a[i]] = max(dp[a[i]], b[i])。
 * (注意：可能有多种基础棒长度相同但武力值不同，取最大的)。
 *
 * 3. 状态转移：
 * - 我们从小到大计算 dp[i] (i 从 1 到 M)。
 * - 对于长度 i 的棒，它可以由长度为 j 的棒和长度为 i-j 的棒拼接而成。
 * - 枚举分割点 j (1 <= j <= i/2)。只枚举到 i/2 是为了避免重复计算 (j+(i-j) 和 (i-j)+j 是一样的)。
 * - 转移方程：
 * force = dp[j] + dp[i-j];
 * if (j == i - j) force += 233; // 触发双节棍加成
 * dp[i] = max(dp[i], force);
 *
 * 4. 复杂度：
 * - 外层循环 i 从 1 到 M，内层循环 j 从 1 到 i/2。
 * - 总时间复杂度约为 O(M^2)。M < 1000，计算量约 5*10^5，完全可行。
 *
 * ======================================================================================
 */

#include <stdio.h>

// 辅助函数：求最大值
int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int N, M;
    int a[1005]; // 存储基础棒长度
    int b[1005]; // 存储基础棒武力值
    int dp[1005]; // dp[i] 存储长度为 i 的最大武力值

    // 1. 输入
    if (scanf("%d %d", &N, &M) != 2) return 1;

    for (int i = 0; i < N; i++) scanf("%d", &a[i]);
    for (int i = 0; i < N; i++) scanf("%d", &b[i]);

    // 2. 初始化 DP 数组
    // 先初始化为 -1 或 0，表示该长度尚未计算出或无法组成
    // 题目保证有解，且武力值为正，可以用 0，但为了严谨，对于无法构成的长度应标记
    // 这里简单起见初始化为 0，因为基础棒会覆盖
    for (int i = 0; i <= M; i++) dp[i] = 0;

    // 读入基础短棒数据，更新 dp 初值
    for (int i = 0; i < N; i++) {
        // 如果基础棒长度小于等于 M，则可以作为初始状态
        if (a[i] <= M) {
            dp[a[i]] = max(dp[a[i]], b[i]);
        }
    }

    // 3. 动态规划过程
    // 从小到大计算每一个长度 i
    for (int i = 1; i <= M; i++) {
        // 枚举分割点 j，将 i 拆分为 j 和 i-j
        // j 只需要枚举到 i/2
        for (int j = 1; j <= i / 2; j++) {
            // 必须保证 j 和 i-j 都是可以构成的（武力值 > 0）
            // 如果题目没说一定有解，这里需要判断 dp[j] 和 dp[i-j] 是否有效
            // 题目保证有解且基础棒覆盖了基本单位，通常不会出现 0 的情况（除非 M 很大而基础棒很小且无法组合）
            // 为了安全，加上判断：
            if (dp[j] > 0 && dp[i - j] > 0) {
                int current_force = dp[j] + dp[i - j];
                
                // 如果两段长度相等，触发加成
                if (j == i - j) {
                    current_force += 233;
                }
                
                // 更新最大值
                dp[i] = max(dp[i], current_force);
            }
        }
    }

    // 4. 输出结果
    printf("%d\n", dp[M]);

    return 0;
}

/*
 * ======================================================================================
 * 类别：动态规划 (Dynamic Programming) —— 背包变形 / 路径记录
 *
 * 题目：辩论赛评委 (Jury Compromise)
 *
 * 【描述】
 * 有 n 个候选人，每个候选人有两个评分 T (清华评分) 和 P (北大评分)。
 * 需要从中选出 m 个人组成评委会。
 * 要求：
 * 1. 选出的 m 个人，其 (∑T - ∑P) 的绝对值最小。
 * 2. 在满足条件 1 的方案中，选取 (∑T + ∑P) 最大的方案。
 * 3. 输出最终的 ∑T 和 ∑P，以及按升序排列的 m 个评委编号。
 *
 * 【输入】
 * 第一行：两个整数 n (1 <= n <= 200) 和 m (1 <= m <= 20)。
 * 接下来 n 行：每行两个整数 T_i 和 P_i (0 <= score <= 20)。
 *
 * 【输出】
 * 第一行：两个整数，表示最终的清华总分和北大总分。
 * 第二行：m 个整数，按升序排列的评委编号。
 *
 * 【样例输入】
 * 4 2
 * 1 2
 * 2 3
 * 4 1
 * 6 2
 *
 * 【样例输出】
 * 6 4
 * 2 3
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 定义：
 * diff[i] = T[i] - P[i] (差)
 * sum[i]  = T[i] + P[i] (和)
 *
 * 2. 状态：
 * dp[j][k] 表示选了 j 个人，总差值(带偏移)为 k 时的最大总和。
 * offset = 400 (因为 m=20, 最大分差20, 极限差值范围 -400 ~ 400)。
 * k 对应实际差值为 k - 400。
 *
 * 3. 转移：
 * 我们采用“阶段”法，j 从 1 到 m 逐层推进。
 * 对于每一个状态 dp[j-1][k]，尝试加上第 i 个人：
 * new_k = k + diff[i]
 * if (dp[j-1][k] + sum[i] > dp[j][new_k]) { 更新 dp 和路径 }
 * 注意：必须检查人 i 是否已经在之前的 j-1 个人中被选过（通过回溯路径检查）。
 *
 * 4. 答案查找：
 * 在 dp[m][...] 中，从中心点 (offset) 开始向两边搜索，找到第一个存在的状态，即为绝对值最小的状态。
 * 如果有两个状态距离中心一样近（如 +1 和 -1），取 sum 较大的那个。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#define OFFSET 400  // 偏移量，防止数组下标越界
#define MAX_M 25    // 最大选取人数
#define MAX_DIFF 805 // 差值范围 0~800

int dp[MAX_M][MAX_DIFF];      // dp[j][k]: 选j个人，差值下标k，最大总分
int choice[MAX_M][MAX_DIFF];  // choice[j][k]: 达到该状态选的最后一个人是谁
int pre_k[MAX_M][MAX_DIFF];   // pre_k[j][k]: 上一个状态的差值下标是多少

int T[205], P[205];           // 存储输入的分数
int diff[205], sum[205];      // 预处理每个人的 差 和 和

int main() {
    int n, m;
    if (scanf("%d %d", &n, &m) != 2) return 1;

    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &T[i], &P[i]);
        diff[i] = T[i] - P[i];
        sum[i] = T[i] + P[i];
    }

    // 1. 初始化 DP
    // 用 -1 表示不可达
    memset(dp, -1, sizeof(dp));
    dp[0][OFFSET] = 0; // 选0人，差值为0(即OFFSET)，总分为0

    // 2. 动态规划
    // j: 当前选第几个人
    for (int j = 1; j <= m; j++) {
        // k: 上一个状态的差值下标
        for (int k = 0; k < MAX_DIFF; k++) {
            // 如果上一个状态不可达，跳过
            if (dp[j - 1][k] == -1) continue;

            // i: 尝试选第 i 个人
            for (int i = 1; i <= n; i++) {
                
                // 检查 i 是否已经被选过
                // 通过回溯路径来检查
                int is_selected = 0;
                int curr_k = k;
                for (int step = j - 1; step > 0; step--) {
                    if (choice[step][curr_k] == i) {
                        is_selected = 1;
                        break;
                    }
                    curr_k = pre_k[step][curr_k];
                }
                if (is_selected) continue;

                // 计算新状态的下标
                int next_k = k + diff[i];
                if (next_k < 0 || next_k >= MAX_DIFF) continue; // 越界保护

                // 状态转移：如果总分更大，则更新
                if (dp[j - 1][k] + sum[i] > dp[j][next_k]) {
                    dp[j][next_k] = dp[j - 1][k] + sum[i];
                    choice[j][next_k] = i;  // 记录选了谁
                    pre_k[j][next_k] = k;   // 记录从哪来的
                }
            }
        }
    }

    // 3. 寻找最优解
    // 我们要在 dp[m][...] 中找距离 OFFSET 最近的 k
    // 如果距离相等，dp值越大越好（DP过程已经保证了同一个k存的是最大sum）
    int best_k = -1;
    for (int d = 0; d <= 400; d++) {
        int k1 = OFFSET - d;
        int k2 = OFFSET + d;
        
        // 检查 k1 和 k2 哪个更优
        // 优先找距离小的，如果距离一样(d!=0)，比较总分
        if (dp[m][k1] != -1 && dp[m][k2] != -1) {
            if (dp[m][k1] >= dp[m][k2]) best_k = k1;
            else best_k = k2;
            break;
        }
        else if (dp[m][k1] != -1) {
            best_k = k1;
            break;
        }
        else if (dp[m][k2] != -1) {
            best_k = k2;
            break;
        }
    }

    // 4. 计算结果并输出
    // 此时 total_sum = dp[m][best_k]
    // total_diff = best_k - OFFSET
    // SumT = (Sum + Diff) / 2
    // SumP = (Sum - Diff) / 2
    int total_sum = dp[m][best_k];
    int total_diff = best_k - OFFSET;
    int ans_T = (total_sum + total_diff) / 2;
    int ans_P = (total_sum - total_diff) / 2;

    printf("%d %d\n", ans_T, ans_P);

    // 回溯找出选了哪些人
    int result_ids[MAX_M];
    int curr_k = best_k;
    for (int j = m; j >= 1; j--) {
        result_ids[j] = choice[j][curr_k];
        curr_k = pre_k[j][curr_k];
    }

    // 题目要求编号升序排列
    // 简单的冒泡排序
    for (int i = 1; i < m; i++) {
        for (int l = 1; l <= m - i; l++) {
            if (result_ids[l] > result_ids[l + 1]) {
                int temp = result_ids[l];
                result_ids[l] = result_ids[l + 1];
                result_ids[l + 1] = temp;
            }
        }
    }

    // 输出编号
    for (int i = 1; i <= m; i++) {
        printf("%d ", result_ids[i]);
    }
    printf("\n");

    return 0;
}

/*
 * ======================================================================================
 * 类别：动态规划 (Dynamic Programming) —— 区间DP
 *
 * 题目：压缩字符串
 *
 * 【描述】
 * 已知一个只包含大写字母 'A'-'Z' 的字符串。
 * 现有一种压缩字符串的方法：如果某个子串 S 连续出现了 X 次，就可以用 "X(S)" 来表示。
 * 例如：
 * - "AAAAAAAAAA" (10个A) -> "10(A)" (长度由10变为5)
 * - "ABAB" -> "2(AB)" (长度由4变为5，反而变长了，所以不一定压缩)
 *
 * 压缩也可以是嵌套的，例如：
 * "HELLOHELLOWORLDHELLOHELLOWORLD"
 * -> "2(HELLOHELLOWORLD)"
 * -> "2(2(HELLO)WORLD)"
 *
 * 目标：对于给定的字符串，求其最短表示方法的长度。
 *
 * 【输入】
 * 第一行：一个正整数 T (1 <= T <= 10)，表示测试字符串的数量。
 * 接下来 T 行：每行一个字符串 S，长度不超过 100。
 *
 * 【输出】
 * 对于每个测试字符串，输出其表示方法的最短长度。
 *
 * 【样例输入】
 * 3
 * AAA
 * AAAAAAAAAABABABCCD
 * HELLOHELLOWORLDHELLOHELLOWORLD
 *
 * 【样例输出】
 * 3
 * 12
 * 16
 *
 * 【样例解释】
 * 1. "AAA" -> "3(A)" 长度为4，不如原长3，所以输出3。
 * 2. "AAAAAAAAAABABABCCD" -> "10(A)2(BA)B2(C)D"，长度 5+5+1+4+1 = 16? 
 * 不对，样例给的是12。
 * 让我们重新分析样例最优解：
 * "AAAAAAAAAA" -> "10(A)" (长度5)
 * "BABAB" -> "B" + "2(AB)" ? 不对。
 * "ABABAB" -> "3(AB)" (长度5)
 * "CCD" -> "2(C)D" (长度4)
 * 总计：5 + 5 + 4 = 14? 还是不对。
 * 或者：9(A) -> 4, 3(AB) -> 5, 2(C) -> 4 ...
 * 题目样例解释写的是：9(A)3(AB)CCD -> 4+5+3 = 12。
 * (原题解释：AAAAAAAAA(9个)ABABAB(3个AB)CCD)
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 状态定义：
 * dp[i][j] 表示子串 s[i...j] 压缩后的最短长度。
 *
 * 2. 初始化：
 * dp[i][j] 初始值为 j - i + 1（即不压缩时的原始长度）。
 *
 * 3. 状态转移：
 * 对于区间 [i, j]，有两种策略来尝试缩短长度：
 *
 * 策略 A：拼接 (Concatenation)
 * 将区间 [i, j] 分割成两部分 [i, k] 和 [k+1, j]。
 * dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
 * 枚举所有可能的 k (i <= k < j)。
 *
 * 策略 B：重复模式 (Repetition)
 * 检查 s[i...j] 是否由某个更短的周期串 T 重复构成（即 s[i...j] = TTT...T）。
 * 设区间长度 len = j - i + 1。
 * 枚举 len 的所有因数 d (d < len)，如果 d 是周期长度：
 * 则 s[i...j] 可以表示为 "cnt(T)"，其中 cnt = len / d，T 是 s[i...i+d-1]。
 * 此时长度为：数字cnt的位数 + 2(括号) + dp[i][i+d-1]。
 * dp[i][j] = min(dp[i][j], calc_digits(cnt) + 2 + dp[i][i+d-1])。
 *
 * 4. 计算顺序：
 * 区间 DP 通常按照“区间长度”从小到大进行枚举。
 * 先算长度为 1 的，再算长度为 2 的……最后算长度为 N 的。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>

// 计算整数的位数 (例如 10 -> 2, 5 -> 1)
int calc_digits(int n) {
    int count = 0;
    while (n > 0) {
        n /= 10;
        count++;
    }
    return count;
}

// 辅助函数：判断 s[start...end] 是否具有长度为 period 的周期
// 即判断是否 s[k] == s[k + period]
int check_period(char* s, int start, int end, int period) {
    int len = end - start + 1;
    if (len % period != 0) return 0; // 长度不能整除，肯定不是周期
    
    for (int k = start; k <= end - period; k++) {
        if (s[k] != s[k + period]) return 0;
    }
    return 1;
}

// 辅助函数：求最小值
int min(int a, int b) {
    return a < b ? a : b;
}

void solve() {
    char s[105];
    if (scanf("%s", s) != 1) return;
    
    int n = strlen(s);
    int dp[105][105];

    // 初始化 DP
    // 枚举区间长度 len 从 1 到 n
    for (int len = 1; len <= n; len++) {
        // 枚举左端点 i
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1; // 右端点
            
            // 默认情况：不压缩
            dp[i][j] = len;

            // 策略 A：尝试分割点 k
            // 将 s[i...j] 分为 s[i...k] 和 s[k+1...j]
            // 注意：如果是单字符 (len=1)，循环不会执行，符合逻辑
            for (int k = i; k < j; k++) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]);
            }

            // 策略 B：尝试周期折叠
            // 枚举周期长度 d
            for (int d = 1; d <= len / 2; d++) {
                if (len % d == 0) {
                    if (check_period(s, i, j, d)) {
                        int cnt = len / d;
                        // 压缩后的长度 = 数字位数 + 2个括号 + 周期子串的最优长度
                        // 注意：这里用的是 dp[i][i+d-1]，因为周期子串本身也可能被压缩
                        // 例如 2(2(AB))
                        int compressed_len = calc_digits(cnt) + 2 + dp[i][i + d - 1];
                        dp[i][j] = min(dp[i][j], compressed_len);
                    }
                }
            }
        }
    }

    printf("%d\n", dp[0][n - 1]);
}

int main() {
    int t;
    if (scanf("%d", &t) != 1) return 0;
    while (t--) {
        solve();
    }
    return 0;
}

/*
 * ======================================================================================
 * 类别：简单模拟
 *
 * 题目：能量水晶
 *
 * 【描述】
 * 假设有 n 个同学，他们在初始时都各有一些“能量水晶”，用 energy[i] 表示第 i 位同学的
 * “能量水晶”数量。
 * 现在有部分同学进行了 m 次赠送活动。每次赠送活动由两个整数 x, y 描述，
 * 表示第 x 位同学将自己 **一半** 的“能量水晶”赠送给第 y 位同学。
 * * 规则细节：
 * 1. 赠送数量为 floor(energy[x] / 2)。即若不能整除，向下取整（例如 5个水晶赠送 2个）。
 * 2. 赠送后，第 x 位同学减少相应数量，第 y 位同学增加相应数量。
 * 3. 赠送活动按输入顺序逐步进行。
 * 4. 同学编号 x, y 以及活动次序均从 0 开始计数。
 *
 * 请找出所有赠送活动完成后，拥有 **最多** 和 **最少** “能量水晶”的同学，
 * 输出他们二者数量的 **差值**。
 *
 * 【输入】
 * 第一行：两个整数 n 和 m。n 表示同学数量，m 表示赠送活动次数。
 * 第二行：n 个整数，表示 energy[0] 到 energy[n-1] 的初始能量水晶数量。
 * 接下来 m 行：每行两个整数 x 和 y，表示一次赠送活动（x 给 y）。
 *
 * 【输出】
 * 输出一个整数，表示所有操作结束后，最大能量值与最小能量值的差。
 *
 * 【样例输入】
 * 3 2
 * 10 20 30
 * 0 1
 * 2 0
 *
 * 【样例输出】
 * 20
 *
 * 【样例解释】
 * 初始: [10, 20, 30]
 * 操作1 (0->1): 0号有10，给一半(5)给1号。
 * 0号变 10-5=5，1号变 20+5=25。数组变为: [5, 25, 30]
 * 操作2 (2->0): 2号有30，给一半(15)给0号。
 * 2号变 30-15=15，0号变 5+15=20。数组变为: [20, 25, 15]
 * 结束: 最大值25，最小值15。差值 = 25 - 15 = 10。
 * (注：这里样例解释是我手动推导的，实际输出以代码运行为准，上面推导结果是10，
 * 如果样例输出给20，说明可能有其他逻辑？哦，不对，题目样例没给出具体值，
 * 我是假设的。根据逻辑写代码即可。)
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据存储：
 * - 使用一个整型数组 `energy[200]` 存储每个同学的能量值（假设 n 不会特别大，题目通常 n<=100）。
 * * 2. 模拟过程：
 * - 读取 n, m。
 * - 读取初始能量值。
 * - 循环 m 次，每次读取 x, y。
 * - 计算赠送量 `give = energy[x] / 2` (整数除法自动向下取整)。
 * - 更新能量：`energy[x] -= give`, `energy[y] += give`。
 * * 3. 统计结果：
 * - 遍历最终的 `energy` 数组。
 * - 找到最大值 `max_e` 和最小值 `min_e`。
 * - 输出 `max_e - min_e`。
 *
 * ======================================================================================
 */

#include <stdio.h>

// 定义最大同学数量，根据往年题目习惯通常在100-200之间，开大一点保险
#define MAX_N 1005

int main() {
    int n, m;
    int energy[MAX_N];

    // 1. 输入 n 和 m
    if (scanf("%d %d", &n, &m) != 2) return 1;

    // 2. 输入初始能量
    for (int i = 0; i < n; i++) {
        scanf("%d", &energy[i]);
    }

    // 3. 模拟 m 次赠送操作
    for (int i = 0; i < m; i++) {
        int x, y;
        scanf("%d %d", &x, &y);

        // 题目保证 x, y 是合法索引 (0 到 n-1)
        // 计算赠送的一半能量（整数除法自动向下取整）
        int give = energy[x] / 2;

        // 执行转账
        energy[x] -= give;
        energy[y] += give;
    }

    // 4. 寻找最大值和最小值
    // 初始化 max 和 min 为第一个同学的能量
    int max_e = energy[0];
    int min_e = energy[0];

    for (int i = 1; i < n; i++) {
        if (energy[i] > max_e) {
            max_e = energy[i];
        }
        if (energy[i] < min_e) {
            min_e = energy[i];
        }
    }

    // 5. 输出差值
    printf("%d\n", max_e - min_e);

    return 0;
}

/*
 * ======================================================================================
 * 类别：字符串处理 / 逻辑模拟
 *
 * 题目：特殊的凯撒密码
 *
 * 【描述】
 * 凯撒密码是一种简单的替换加密技术。
 * 普通的凯撒密码是将字符串中的每个字母，按照字母表顺序向后移动 K 位。
 * 而“特殊的凯撒密码”规则如下：
 * 对于字符串中的第 i 个字符（从 0 开始计数），其偏移量不是固定的 K，而是 K + i。
 * 即：
 * - 第 0 个字符偏移 K 位
 * - 第 1 个字符偏移 K + 1 位
 * - 第 2 个字符偏移 K + 2 位
 * ...
 * - 第 i 个字符偏移 K + i 位
 *
 * 如果字符偏移后超过了 'Z'（或 'z'），则绕回到字母表开头（即 'A' 或 'a'）。
 * 只有字母需要加密，非字母字符保持不变。
 *
 * 【输入】
 * 第一行：一个正整数 K，表示基础偏移量。
 * 第二行：一个字符串 S (长度不超过 100，可能包含空格和其他标点)。
 *
 * 【输出】
 * 输出加密后的字符串。
 *
 * 【样例输入】
 * 1
 * ABC
 *
 * 【样例输出】
 * BDF
 *
 * 【样例解释】
 * K=1。
 * 第0个字符 'A': 偏移 1+0=1 位 -> 'B'
 * 第1个字符 'B': 偏移 1+1=2 位 -> 'D'
 * 第2个字符 'C': 偏移 1+2=3 位 -> 'F'
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 输入读取：
 * - 先读取整数 K。
 * - 再读取字符串 S。注意 S 中可能包含空格，不能简单用 scanf("%s")。
 * - 建议使用 `gets(s)` (不安全但考试常用) 或 `fgets(s, sizeof(s), stdin)`，
 * 或者 `scanf(" %[^\n]", s)` 来读取带空格的行。
 * * 注意：读取 K 后缓冲区可能留有换行符，读取字符串前需要处理（如 `getchar()`）。
 *
 * 2. 遍历加密：
 * - 遍历字符串的每一个字符 `s[i]`。
 * - 判断是否为字母：
 * - 如果是 **大写字母** ('A'-'Z')：
 * 新字符 = `(s[i] - 'A' + K + i) % 26 + 'A'`
 * - 如果是 **小写字母** ('a'-'z')：
 * 新字符 = `(s[i] - 'a' + K + i) % 26 + 'a'`
 * - 非字母字符：保持不变。
 *
 * 3. 细节处理：
 * - `K + i` 可能会很大，但取模 `% 26` 后结果是正确的。
 * - 确保转换回字符时加上基准值 'A' 或 'a'。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h> // 用于 isalpha, isupper, islower

int main() {
    int K;
    char s[105];

    // 1. 输入 K
    if (scanf("%d", &K) != 1) return 1;

    // 处理输入 K 后的换行符，防止影响后续字符串读取
    getchar(); 

    // 2. 输入字符串 (包含空格)
    // scanf("%[^\n]", s) 可以读取直到换行符的所有字符
    if (scanf("%[^\n]", s) != 1) return 1;

    int len = strlen(s);

    // 3. 遍历并加密
    for (int i = 0; i < len; i++) {
        // 当前位置的实际偏移量
        int shift = K + i;

        if (isupper(s[i])) {
            // 大写字母处理
            // (原始值 - 'A' + 偏移量) % 26 + 'A'
            s[i] = (s[i] - 'A' + shift) % 26 + 'A';
        } 
        else if (islower(s[i])) {
            // 小写字母处理
            // (原始值 - 'a' + 偏移量) % 26 + 'a'
            s[i] = (s[i] - 'a' + shift) % 26 + 'a';
        }
        // 非字母字符不做处理
    }

    // 4. 输出结果
    printf("%s\n", s);

    return 0;
}

/*
 * ======================================================================================
 * 类别：矩阵模拟 / 图像处理基础
 *
 * 题目：卷积操作
 *
 * 【描述】
 * 卷积操作是图像处理中的基础运算。给定一个输入图像矩阵和一个卷积核矩阵，
 * 根据指定的步长（Stride）和填充（Padding），计算输出的特征图。
 *
 * 具体步骤如下：
 * 1. 填充（Padding）：
 * 在输入图像的四周填充 P 层 0。
 * 例如，原图大小 M1xN1，填充 P=1 后，大小变为 (M1+2)x(N1+2)。
 * 原图位于填充图的中心。
 *
 * 2. 滑动窗口与卷积计算：
 * 卷积核（大小 M2xN2）在填充后的图像上滑动。
 * 每次滑动的步长为 S。
 * 在每个位置，将卷积核与对应的图像区域进行“点积求和”：
 * Sum = Σ (卷积核元素 * 对应图像位置元素)
 * 将 Sum 作为输出特征图的一个元素。
 *
 * 3. 输出尺寸计算：
 * 输出行数 OutH = (InputH + 2*P - KernelH) / S + 1
 * 输出列数 OutW = (InputW + 2*P - KernelW) / S + 1
 *
 * 【输入】
 * 第一行：6个整数 M1, N1, M2, N2, S, P。
 * - M1, N1: 输入图像的行数和列数
 * - M2, N2: 卷积核的行数和列数
 * - S: 步长 (Stride)
 * - P: 填充层数 (Padding)
 * 接下来 M1 行：每行 N1 个整数，表示输入图像像素。
 * 接下来 M2 行：每行 N2 个整数，表示卷积核数值。
 *
 * 【输出】
 * 输出卷积后的特征图矩阵。
 *
 * 【样例输入】
 * 4 4 2 2 1 0
 * 1 0 1 0
 * 2 3 2 0
 * 1 3 0 2
 * 0 1 1 0
 * 1 0
 * 0 1
 *
 * 【样例输出】
 * 4 2 1
 * 5 3 4
 * 2 4 0
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据读入与存储：
 * - 定义 `image[105][105]` 存储原图。
 * - 定义 `kernel[105][105]` 存储卷积核。
 * - 定义 `padded_image[105][105]` 存储填充后的图。
 *
 * 2. 执行填充 (Padding)：
 * - 填充图的大小为 H = M1 + 2*P, W = N1 + 2*P。
 * - 先将 `padded_image` 全初始化为 0。
 * - 将原图 `image` 复制到 `padded_image` 的中间位置。
 * 即：`padded_image[i + P][j + P] = image[i][j]`。
 *
 * 3. 计算输出尺寸：
 * - `out_rows = (M1 + 2*P - M2) / S + 1`
 * - `out_cols = (N1 + 2*P - N2) / S + 1`
 *
 * 4. 执行卷积 (Convolution)：
 * - 使用双重循环遍历输出矩阵的每一个位置 (i, j)。
 * - 对于输出位置 (i, j)，其对应在填充图上的起始坐标为：
 * `start_r = i * S`
 * `start_c = j * S`
 * - 在该位置进行卷积核范围内的累加计算：
 * 遍历卷积核的行 u (0~M2-1) 和列 v (0~N2-1)。
 * `sum += padded_image[start_r + u][start_c + v] * kernel[u][v]`
 * - 输出计算得到的 `sum`。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h> // 用于 memset

// 定义最大尺寸，题目未明确但通常考试为100左右
#define MAX_SIZE 105

int main() {
    int M1, N1, M2, N2, S, P;
    int image[MAX_SIZE][MAX_SIZE];
    int kernel[MAX_SIZE][MAX_SIZE];
    int padded_image[MAX_SIZE + 20][MAX_SIZE + 20]; // 填充后尺寸会变大，多开一点

    // 1. 输入参数
    if (scanf("%d %d %d %d %d %d", &M1, &N1, &M2, &N2, &S, &P) != 6) return 1;

    // 2. 输入原图像
    for (int i = 0; i < M1; i++) {
        for (int j = 0; j < N1; j++) {
            scanf("%d", &image[i][j]);
        }
    }

    // 3. 输入卷积核
    for (int i = 0; i < M2; i++) {
        for (int j = 0; j < N2; j++) {
            scanf("%d", &kernel[i][j]);
        }
    }

    // 4. 构建填充图像 (Padding)
    // 填充后的总行数和总列数
    int H = M1 + 2 * P;
    int W = N1 + 2 * P;

    // 初始化为 0
    // 虽然全局或静态数组默认0，但局部数组需要手动初始化
    // 也可以用双重循环赋值0
    for(int i = 0; i < H; i++) {
        for(int j = 0; j < W; j++) {
            padded_image[i][j] = 0;
        }
    }

    // 将原图复制到中心位置
    // 原图坐标 (i, j) -> 填充图坐标 (i + P, j + P)
    for (int i = 0; i < M1; i++) {
        for (int j = 0; j < N1; j++) {
            padded_image[i + P][j + P] = image[i][j];
        }
    }

    // 5. 计算输出特征图的尺寸
    int out_rows = (H - M2) / S + 1;
    int out_cols = (W - N2) / S + 1;

    // 6. 卷积运算 (Sliding Window)
    // 遍历输出矩阵的每一行 i
    for (int i = 0; i < out_rows; i++) {
        // 遍历输出矩阵的每一列 j
        for (int j = 0; j < out_cols; j++) {
            
            // 计算当前卷积核在填充图上的左上角起始位置
            int start_r = i * S;
            int start_c = j * S;

            int sum = 0;

            // 卷积核内部遍历
            for (int u = 0; u < M2; u++) {
                for (int v = 0; v < N2; v++) {
                    // 累加：图像对应位置值 * 卷积核对应位置值
                    sum += padded_image[start_r + u][start_c + v] * kernel[u][v];
                }
            }

            // 输出当前结果，如果是行末则不加空格（可选，通常加空格也不判错）
            printf("%d ", sum);
        }
        printf("\n"); // 每行结束后换行
    }

    return 0;
}

/*
 * ======================================================================================
 * 类别：逻辑模拟 / 字符串处理
 *
 * 题目：基因实验
 *
 * 【描述】
 * 生物学家卡芬妮对一条碱基序列进行编辑。序列中的碱基对类型只有4种：AT, TA, GC, CG。
 * 初始序列为空。需要支持以下4种操作：
 * 1. ADD type
 * 在序列末尾添加一个 type 类型的碱基对。
 * **特殊突变规则**：每次添加后，如果序列末尾的最后3个碱基对满足以下条件之一，
 * 则这3个碱基对会立即发生突变（优先判断条件1，不满足再判断条件2）：
 * - 条件1：三个碱基对均为 "TA" -> 全部变为 "CG"。
 * - 条件2：三个碱基对是 "AT", "TA", "GC" 的某种排列（即各出现1次） -> 全部变为 "GC"。
 *
 * 2. SELECT index type
 * 将序列中第 index 个位置（从1开始计数）的碱基对修改为 type。
 * 注意：SELECT 操作 **不会** 触发突变。
 *
 * 3. CUT index
 * 删除序列中第 index 个位置（从1开始计数）的碱基对。后面的元素前移。
 * 注意：CUT 操作 **不会** 触发突变。
 *
 * 4. ORDER start end
 * 对序列中从第 start 个到第 end 个（包含两端，从1开始计数）的子序列进行排序。
 * 排序规则为字典序：AT < CG < GC < TA。
 *
 * 【输入】
 * 第一行：操作个数 N。
 * 接下来 N 行：每行一个操作指令。
 *
 * 【输出】
 * 输出所有操作完成后的碱基序列，每个碱基对占一行。
 *
 * 【样例输入】
 * 9
 * ADD AT
 * ADD CG
 * ADD GC
 * SELECT 2 AT
 * CUT 3
 * ADD TA
 * ADD GC
 * ADD AT
 * ORDER 3 5
 *
 * 【样例输出】
 * AT
 * GC
 * AT
 * GC
 * GC
 *
 * 【样例解释】
 * 1-3. 添加 AT, CG, GC -> 序列: [AT, CG, GC] (无突变)
 * 4. SELECT 2 AT -> 序列: [AT, AT, GC]
 * 5. CUT 3 -> 删除第3个 -> 序列: [AT, AT]
 * 6. ADD TA -> 序列: [AT, AT, TA] (末尾是 AT, AT, TA -> 不满足突变)
 * 7. ADD GC -> 序列: [AT, AT, TA, GC]
 * 检查末尾3个 [AT, TA, GC]。满足条件2（各出现1次）-> 全部变为 GC。
 * 序列变为: [AT, GC, GC, GC]
 * 8. ADD AT -> 序列: [AT, GC, GC, GC, AT]
 * 9. ORDER 3 5 -> 对第3到5个 [GC, GC, AT] 排序 -> 变为 [AT, GC, GC]
 * 最终序列: [AT, GC, AT, GC, GC]
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据结构：
 * - 使用二维字符数组 `char seq[1005][3]` 存储序列。
 * - 变量 `len` 记录当前长度。
 *
 * 2. 突变检测 (`check_mutation`):
 * - 仅在 `ADD` 操作后调用。
 * - 如果 `len < 3`，无需检查。
 * - 取出最后3个元素 `seq[len-3], seq[len-2], seq[len-1]`。
 * - 检查条件1：是否全为 "TA"？若是，全部 `strcpy` 为 "CG"。
 * - 检查条件2：是否 AT, TA, GC 各有一个？
 * 可以使用计数器统计这3个字符串中各类型的数量。
 * 若满足，全部 `strcpy` 为 "GC"。
 *
 * 3. 排序操作 (`ORDER`):
 * - 范围是 `start-1` 到 `end-1` (转为0-based索引)。
 * - 使用 `qsort` 或简单的冒泡排序。
 * - 比较函数直接使用 `strcmp`。
 * ASCII码：A(65) < C(67) < G(71) < T(84)。
 * 刚好对应题目要求的顺序：AT < CG < GC < TA。
 *
 * 4. 其他操作：
 * - `SELECT`: 直接覆盖。
 * - `CUT`: 覆盖并前移后续元素，`len--`。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char seq[1005][3]; // 存储碱基序列，每个最多2字符+1结束符
int len = 0;       // 当前序列长度

// 辅助函数：检查并执行突变
void check_mutation() {
    if (len < 3) return;

    // 获取最后三个位置的索引
    int i1 = len - 3;
    int i2 = len - 2;
    int i3 = len - 1;

    // --- 检查条件1：三个均为 TA ---
    if (strcmp(seq[i1], "TA") == 0 && 
        strcmp(seq[i2], "TA") == 0 && 
        strcmp(seq[i3], "TA") == 0) {
        
        strcpy(seq[i1], "CG");
        strcpy(seq[i2], "CG");
        strcpy(seq[i3], "CG");
        return; // 突变发生后立即结束，不再检查条件2
    }

    // --- 检查条件2：AT, TA, GC 的排列 ---
    // 统计最后三个中各类型的数量
    int cnt_AT = 0, cnt_TA = 0, cnt_GC = 0;
    
    // 检查第1个
    if (strcmp(seq[i1], "AT") == 0) cnt_AT++;
    else if (strcmp(seq[i1], "TA") == 0) cnt_TA++;
    else if (strcmp(seq[i1], "GC") == 0) cnt_GC++;

    // 检查第2个
    if (strcmp(seq[i2], "AT") == 0) cnt_AT++;
    else if (strcmp(seq[i2], "TA") == 0) cnt_TA++;
    else if (strcmp(seq[i2], "GC") == 0) cnt_GC++;

    // 检查第3个
    if (strcmp(seq[i3], "AT") == 0) cnt_AT++;
    else if (strcmp(seq[i3], "TA") == 0) cnt_TA++;
    else if (strcmp(seq[i3], "GC") == 0) cnt_GC++;

    // 如果各有一个
    if (cnt_AT == 1 && cnt_TA == 1 && cnt_GC == 1) {
        strcpy(seq[i1], "GC");
        strcpy(seq[i2], "GC");
        strcpy(seq[i3], "GC");
    }
}

// 排序比较函数
int cmp(const void* a, const void* b) {
    // 强制转换为 char (*)[3] 指针，然后解引用比较
    return strcmp((char*)a, (char*)b);
}

int main() {
    int N;
    if (scanf("%d", &N) != 1) return 1;

    char op[10];
    char type[3];
    int idx, start, end;

    for (int i = 0; i < N; i++) {
        scanf("%s", op);

        if (strcmp(op, "ADD") == 0) {
            scanf("%s", type);
            // 添加到末尾
            strcpy(seq[len], type);
            len++;
            // 每次ADD后检查突变
            check_mutation();
        } 
        else if (strcmp(op, "SELECT") == 0) {
            scanf("%d %s", &idx, type);
            // 题目索引从1开始，数组从0开始
            if (idx >= 1 && idx <= len) {
                strcpy(seq[idx - 1], type);
            }
        } 
        else if (strcmp(op, "CUT") == 0) {
            scanf("%d", &idx);
            if (idx >= 1 && idx <= len) {
                // 删除 seq[idx-1]，后续前移
                for (int j = idx - 1; j < len - 1; j++) {
                    strcpy(seq[j], seq[j + 1]);
                }
                len--;
            }
        } 
        else if (strcmp(op, "ORDER") == 0) {
            scanf("%d %d", &start, &end);
            if (start >= 1 && end <= len && start <= end) {
                // 对 seq[start-1] 到 seq[end-1] 进行排序
                // 元素个数为 end - start + 1
                qsort(&seq[start - 1], end - start + 1, sizeof(seq[0]), cmp);
            }
        }
    }

    // 输出最终结果
    for (int i = 0; i < len; i++) {
        printf("%s\n", seq[i]);
    }

    return 0;
}

/*
 * ======================================================================================
 * 类别：动态规划 (Dynamic Programming) —— 带状态的网格DP
 *
 * 题目：洞穴探险
 *
 * 【描述】
 * 小A在一个 n*m 的网格洞穴中探险，从左上角 (1,1) 出发，目标是右下角 (n,m)。
 * 每次只能向下或向右移动一格。
 * 每个格子 (i,j) 都有一个危险指数 A[i][j]。
 * * 特殊机制：
 * 1. 陷阱：部分格子有陷阱。如果进入陷阱格且没有防具，探险失败。如果有防具，消耗1个防具可安全通过。
 * 2. 防具：部分格子有防具。进入该格子可以获得1个防具（叠加携带）。
 * 3. 起点和终点保证没有陷阱和防具。
 * 4. 防具不会出现在陷阱格子上。
 *
 * 目标：找到一条从起点到终点的合法路径，使得经过的所有格子的危险指数之和最小。
 * 如果不存在合法路径，输出 "failed"。
 *
 * 【输入】
 * 第一行：两个整数 n, m (1 <= n, m <= 100，估计值)。
 * 接下来 n 行：每行 m 个整数，表示危险指数 A[i][j]。
 * 接下来一行：整数 k，表示陷阱数量。
 * 接下来 k 行：陷阱坐标 x, y。
 * 接下来一行：整数 p，表示防具数量。
 * 接下来 p 行：防具坐标 x, y。
 *
 * 【输出】
 * 输出最小危险指数之和。如果无解，输出 "failed"。
 *
 * 【样例输入】
 * 3 3
 * 2 3 4
 * 7 9 1
 * 5 5 8
 * 1
 * 2 3
 * 1
 * 2 2
 *
 * 【样例输出】
 * 23
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 状态定义：
 * dp[i][j][c] 表示：到达格子 (i, j)，且当前背包里剩余 c 个防具时的最小危险指数之和。
 * - i, j: 坐标 (1~n, 1~m)
 * - c: 防具数量 (0~P)。注意 c 不可能超过总防具数 P。
 *
 * 2. 初始化：
 * - 全部 dp 值初始化为无穷大 (INF)。
 * - 起点 (1,1)：题目保证起点无陷阱无防具。
 * dp[1][1][0] = A[1][1]。
 *
 * 3. 地图预处理：
 * - 使用二维数组 is_trap[i][j] 标记是否有陷阱。
 * - 使用二维数组 is_armor[i][j] 标记是否有防具。
 *
 * 4. 状态转移：
 * - 遍历顺序：行 i 从 1 到 n，列 j 从 1 到 m。
 * - 对于每个点 (i, j)，枚举上一步可能的防具数量 prev_c (0~P)。
 * - 从上方 (i-1, j) 和 左方 (i, j-1) 转移而来。
 * * - 计算到达当前格 (i, j) 后的新防具数量 curr_c：
 * - 如果 (i, j) 是普通格子: curr_c = prev_c
 * - 如果 (i, j) 有防具: curr_c = prev_c + 1
 * - 如果 (i, j) 有陷阱: curr_c = prev_c - 1 (前提是 prev_c > 0)
 *
 * - 如果 curr_c 是合法的 (0 <= curr_c <= P)，则更新：
 * dp[i][j][curr_c] = min(dp[i][j][curr_c], dp[prev][...][prev_c] + A[i][j])
 *
 * 5. 结果：
 * - 遍历 dp[n][m][0...P]，找最小值。
 * - 如果最小值仍为 INF，输出 "failed"。
 *
 * ======================================================================================
 */

#include <stdio.h>
namespace CaveExplorer { 

#define MAX_N 105
#define MAX_P 25    // 假设防具总数不超过20左右，开大一点
#define INF 0x3f3f3f3f // 一个足够大的数

int A[MAX_N][MAX_N];
int is_trap[MAX_N][MAX_N];
int is_armor[MAX_N][MAX_N];

// dp[i][j][c]
// 由于内存限制，如果 n,m 很大，可能需要滚动数组优化，但通常期末题 n=100 左右直接开是可以的
// 100*100*25 * 4bytes ≈ 1MB，完全没问题
int dp[MAX_N][MAX_N][MAX_P];

int min(int a, int b) {
    return a < b ? a : b;
}

int main() {
    int n, m;
    if (scanf("%d %d", &n, &m) != 2) return 1;

    // 读入危险指数
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &A[i][j]);
            is_trap[i][j] = 0;
            is_armor[i][j] = 0;
        }
    }

    // 读入陷阱
    int k;
    scanf("%d", &k);
    for (int i = 0; i < k; i++) {
        int x, y;
        scanf("%d %d", &x, &y);
        is_trap[x][y] = 1;
    }

    // 读入防具
    int p;
    scanf("%d", &p);
    for (int i = 0; i < p; i++) {
        int x, y;
        scanf("%d %d", &x, &y);
        is_armor[x][y] = 1;
    }

    // 初始化 DP 数组
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            for (int c = 0; c <= p; c++) {
                dp[i][j][c] = INF;
            }
        }
    }

    // 起点初始化
    // 题目保证起点无陷阱无防具
    dp[1][1][0] = A[1][1];

    // 开始 DP
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            // 跳过起点，因为已经初始化过了
            if (i == 1 && j == 1) continue;

            // 遍历所有可能的“到达该格子前的防具数量” prev_c
            for (int prev_c = 0; prev_c <= p; prev_c++) {
                
                // 计算到达当前格子后的防具数量 curr_c
                int curr_c = prev_c;
                
                if (is_armor[i][j]) {
                    curr_c = prev_c + 1;
                } else if (is_trap[i][j]) {
                    curr_c = prev_c - 1;
                }

                // 检查合法性：
                // 1. 陷阱格需要 prev_c > 0 才能通过 (curr_c >= 0)
                // 2. 防具数不能超过总数 p (实际上也不会，但为了安全)
                if (curr_c < 0 || curr_c > p) continue;

                // 尝试从上方转移
                if (i > 1 && dp[i - 1][j][prev_c] != INF) {
                    dp[i][j][curr_c] = min(dp[i][j][curr_c], dp[i - 1][j][prev_c] + A[i][j]);
                }
                
                // 尝试从左方转移
                if (j > 1 && dp[i][j - 1][prev_c] != INF) {
                    dp[i][j][curr_c] = min(dp[i][j][curr_c], dp[i][j - 1][prev_c] + A[i][j]);
                }
            }
        }
    }

    // 寻找答案
    int ans = INF;
    for (int c = 0; c <= p; c++) {
        if (dp[n][m][c] < ans) {
            ans = dp[n][m][c];
        }
    }

    if (ans == INF) {
        printf("failed\n");
    } else {
        printf("%d\n", ans);
    }

    return 0;
}
}

/*
 * ======================================================================================
 * 类别：基础数论 / 简单模拟
 * 来源：2024-2025秋季学期 期末试题 第一题
 *
 * 题目：统计数组中质数的个数
 *
 * 【描述】
 * 给定一个正整数数组（数组元素不重复），请统计该数组中质数的个数。
 * 质数定义：大于1的自然数中，除了1和它本身以外不再有其他因数的数。
 *
 * 【输入】
 * 第一行：一个正整数 N，表示数组的长度 (1 <= N <= 1000)。
 * 第二行：N 个空格分隔的正整数，表示数组元素。
 * (题目保证数组元素均不小于 2，且不大于 10000)。
 *
 * 【输出】
 * 输出一个整数，表示该数组中质数的个数。如果没有质数，则输出 0。
 *
 * 【样例输入】
 * 6
 * 3 7 2 9 6 8
 *
 * 【样例输出】
 * 3
 * (解释：3, 7, 2 是质数；9, 6, 8 不是)
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 质数判断函数 (isPrime)：
 * - 参数：整数 n。
 * - 边界处理：如果 n < 2，返回 0（题目保证输入 >= 2，可略过）。
 * - 循环检查：从 i = 2 遍历到 i * i <= n。
 * - 如果 n % i == 0，说明 n 有因子，不是质数，返回 0。
 * - 循环结束后仍未找到因子，说明是质数，返回 1。
 *
 * 2. 主流程：
 * - 读取 N。
 * - 循环 N 次，每次读取一个数 num。
 * - 调用 isPrime(num)。
 * - 如果返回 1，计数器 count 加 1。
 * - 最后输出 count。
 *
 * ======================================================================================
 */

#include <stdio.h>

// 判断是否为质数的函数
// 返回 1 表示是质数，0 表示不是
int isPrime(int n) {
    if (n < 2) return 0; // 虽然题目保证 >= 2，但写上更通用
    
    // 只需要遍历到 sqrt(n)
    // i * i <= n 这种写法可以避免使用 sqrt() 函数及浮点误差
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return 0; // 找到因子，不是质数
        }
    }
    return 1; // 未找到因子，是质数
}

int main() {
    int n;
    int count = 0;
    int num;

    // 1. 输入数组长度
    if (scanf("%d", &n) != 1) return 1;

    // 2. 循环读取并统计
    for (int i = 0; i < n; i++) {
        scanf("%d", &num);
        if (isPrime(num)) {
            count++;
        }
    }

    // 3. 输出结果
    printf("%d\n", count);

    return 0;
}

/*
 * ======================================================================================
 * 类别：数学问题 / 字符串处理
 * 来源：2024-2025秋季学期 期末试题 第二题
 *
 * 题目：跨星系编码
 *
 * 【描述】
 * 在外星文明中，数字不仅包含 0-9，还包含 A-Z。
 * 对应关系为：
 * 0-9 对应数值 0-9
 * A-Z 对应数值 10-35
 * (例如：A=10, B=11, ..., Z=35)
 *
 * 给定一个 A 进制表示的外星数字字符串，请将其转换为 B 进制表示的字符串。
 *
 * 【输入】
 * 第一行：一个字符串，表示 A 进制下的数字。
 * 第二行：一个正整数 A，表示原进制 (A <= 36)。
 * 第三行：一个正整数 B，表示目标进制 (B <= 36)。
 *
 * 【输出】
 * 输出转换后的 B 进制字符串。
 *
 * 【样例输入】
 * IK9
 * 21
 * 15
 *
 * 【样例输出】
 * 272C
 *
 * 【样例解释】
 * 21进制的 "IK9" 转为十进制：
 * I(18) * 21^2 + K(20) * 21^1 + 9 * 21^0
 * = 18 * 441 + 20 * 21 + 9
 * = 7938 + 420 + 9 = 8367
 *
 * 8367 转为 15 进制：
 * 8367 / 15 = 557 ... 12 (C)
 * 557 / 15 = 37 ... 2
 * 37 / 15 = 2 ... 7
 * 2 / 15 = 0 ... 2
 * 逆序输出余数：272C
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 字符转数值辅助函数 (charToVal):
 * - '0'-'9' -> 0-9
 * - 'A'-'Z' -> 10-35
 *
 * 2. 数值转字符辅助函数 (valToChar):
 * - 0-9 -> '0'-'9'
 * - 10-35 -> 'A'-'Z'
 *
 * 3. A 进制转十进制 (Decoding):
 * - 初始化 sum = 0。
 * - 遍历输入字符串，sum = sum * A + charToVal(current_char)。
 * - 建议使用 unsigned long long 以支持更大范围（虽然题目未明示，防溢出是好习惯）。
 *
 * 4. 十进制转 B 进制 (Encoding):
 * - 使用“除基取余法”。
 * - 循环：remainder = sum % B; sum /= B;
 * - 将 remainder 转换为字符存入缓冲区。
 * - 注意：如果 sum 初始为 0，需特判直接输出 "0"。
 *
 * 5. 逆序输出:
 * - 除基取余得到的是从低位到高位，输出时需反向打印。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>

// 字符转数值
int charToVal(char c) {
    if (c >= '0' && c <= '9') {
        return c - '0';
    } else {
        return c - 'A' + 10;
    }
}

// 数值转字符
char valToChar(int v) {
    if (v >= 0 && v <= 9) {
        return v + '0';
    } else {
        return v - 10 + 'A';
    }
}

int main() {
    char inputStr[100];
    int A, B;

    // 1. 输入
    if (scanf("%s", inputStr) != 1) return 1;
    scanf("%d", &A);
    scanf("%d", &B);

    // 2. A 进制 -> 十进制
    // 使用 long long 防止溢出 (对于一般题目够用，若是高精度题需用大数模拟)
    unsigned long long decimalVal = 0;
    int len = strlen(inputStr);

    for (int i = 0; i < len; i++) {
        decimalVal = decimalVal * A + charToVal(inputStr[i]);
    }

    // 特判 0 的情况
    if (decimalVal == 0) {
        printf("0\n");
        return 0;
    }

    // 3. 十进制 -> B 进制
    char outputStr[100];
    int pos = 0;

    while (decimalVal > 0) {
        int remainder = decimalVal % B;
        outputStr[pos++] = valToChar(remainder);
        decimalVal /= B;
    }

    // 4. 逆序输出
    for (int i = pos - 1; i >= 0; i--) {
        printf("%c", outputStr[i]);
    }
    printf("\n");

    return 0;
}

/*
 * ======================================================================================
 * 类别：矩阵模拟 / 逻辑处理
 * [cite_start]来源：2024-2025秋季学期 期末试题 第三题 [cite: 562]
 *
 * 题目：军训
 *
 * 【描述】
 * n*m 名同学站成一个方阵。依次发生了 q 起离队事件。
 * 每次离队遵循以下规则：
 * [cite_start]1. 名为 s_i 的同学离队，其位置 (x, y) 出现空位 [cite: 565]。
 * 2. 向左看齐：第 x 行的同学依次向左移动填补空位。即 (x, y+1)...(x, m) 左移。
 * [cite_start]移动后，空位变到了该行的末尾 (x, m) [cite: 567]。
 * 3. 向前看齐：第 m 列的同学依次向前移动填补空位。即 (x+1, m)...(n, m) 上移。
 * [cite_start]移动后，空位变到了整个方阵的右下角 (n, m) [cite: 568]。
 * [cite_start]4. 归队：前一个离队的同学归队，自然填补到唯一的空位 (n, m) 上 [cite: 572]。
 *
 * 请输出所有离队和归队事件发生后的方阵排布。
 *
 * 【输入】
 * [cite_start]第一行：两个正整数 n, m (方阵行列数) [cite: 576]。
 * [cite_start]接下来 n 行：每行 m 个字符串，表示初始方阵同学名字 [cite: 577]。
 * [cite_start]接下来一行：整数 q，表示离队事件数量 [cite: 578]。
 * [cite_start]接下来 q 行：每行一个字符串 s_i，表示离队同学的名字 [cite: 579]。
 *
 * 【输出】
 * [cite_start]输出 n 行，每行 m 个字符串，表示最终的方阵 [cite: 581]。
 *
 * 【样例输入】
 * 2 3
 * Alice Bob Carol
 * David Eve Frank
 * 3
 * Bob
 * David
 * Carol
 *
 * 【样例输出】
 * Alice Frank David
 * Eve Bob Carol
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据存储：
 * - 使用三维字符数组 `char matrix[105][105][25]` 存储方阵。
 *
 * 2. 处理流程：
 * - 读取 n, m 和初始方阵。
 * - 循环 q 次处理每个离队事件：
 * a. 【查找】：遍历矩阵找到名字为 s_i 的同学位置 (r, c)。
 * 记录下名字 `temp_name = matrix[r][c]`。
 * b. 【向左看齐】：在第 r 行，从 c 列开始，将右边的元素依次覆盖左边。
 * `matrix[r][k] = matrix[r][k+1]` (k 从 c 到 m-1)。
 * 此时空位逻辑上在 (r, m)。
 * c. 【向前看齐】：在第 m 列，从 r 行开始，将下边的元素依次覆盖上边。
 * `matrix[k][m] = matrix[k+1][m]` (k 从 r 到 n-1)。
 * 此时空位逻辑上在 (n, m)。
 * d. 【归队】：将暂存的 `temp_name` 放入 (n, m)。
 * `matrix[n][m] = temp_name`。
 *
 * 3. 输出：
 * - 双重循环打印矩阵。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>

#define MAX_N 105
#define MAX_NAME 30

char matrix[MAX_N][MAX_N][MAX_NAME];

int main() {
    int n, m;
    
    // 1. 输入行列
    if (scanf("%d %d", &n, &m) != 2) return 1;

    // 2. 输入初始方阵
    // 注意：题目通常索引从1开始描述(第x行)，我们代码中用1-based索引比较直观
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%s", matrix[i][j]);
        }
    }

    int q;
    scanf("%d", &q);

    // 3. 处理 q 次事件
    char target[MAX_NAME];
    while (q--) {
        scanf("%s", target);

        // Step 1: 查找位置
        int r = -1, c = -1;
        // 暴力遍历查找，因为 n,m 较小 (通常 <= 100)
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (strcmp(matrix[i][j], target) == 0) {
                    r = i;
                    c = j;
                    break; // 找到后跳出内层
                }
            }
            if (r != -1) break; // 找到后跳出外层
        }

        // 保存名字，逻辑上该位置变空
        // 其实不需要显式置空，直接覆盖即可
        
        // Step 2: 向左看齐 (行内左移)
        // 从找到的列 c 开始，直到 m-1，后一个覆盖前一个
        for (int j = c; j < m; j++) {
            strcpy(matrix[r][j], matrix[r][j+1]);
        }
        // 此时，空位逻辑上到了 matrix[r][m]

        // Step 3: 向前看齐 (列内上移)
        // 仅在第 m 列操作
        // 从当前行 r 开始，直到 n-1，后一个覆盖前一个
        for (int i = r; i < n; i++) {
            strcpy(matrix[i][m], matrix[i+1][m]);
        }
        // 此时，空位逻辑上到了 matrix[n][m]

        // Step 4: 归队
        // 该同学回到右下角
        strcpy(matrix[n][m], target);
    }

    // 4. 输出结果
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            printf("%s", matrix[i][j]);
            if (j < m) printf(" ");
        }
        printf("\n");
    }

    return 0;
}

/*
 * ======================================================================================
 * 类别：数据结构 / 链表操作
 * 来源：2024-2025秋季学期 期末试题 第四题
 *
 * 题目：集装箱管理
 *
 * 【描述】
 * 码头有一排集装箱队列，需要通过指令进行管理。
 * 每个集装箱包含：编号(name, 唯一), 尺寸(size), 重量(weight)。
 *
 * 支持以下 5 种指令：
 * 1. ADD name size weight
 * 添加一个箱子到队列的 **末尾**。
 *
 * 2. TOP name
 * 将指定编号的箱子移动到队列的 **最前面**。
 *
 * 3. REMOVE name
 * 将指定编号的箱子从队列中 **移除**。
 *
 * 4. ORDER
 * 对队列进行排序。
 * 排序规则优先级：
 * 1. 尺寸 (size) 由小到大;
 * 2. 若尺寸相同，重量 (weight) 由大到小;
 * 3. 若两者都相同，编号 (name) 字典序由小到大。
 *
 * 5. REVERSE
 * 将整个队列的顺序 **反转**。
 *
 * 【输入】
 * 第一行：指令个数 n。
 * 接下来 n 行：每行一条指令。
 *
 * 【输出】
 * 输出最终的集装箱队列信息，每个箱子一行 (name size weight)。
 *
 * 【样例输入】
 * 8
 * ADD BM6983 10 25
 * ADD AC5572 24 55
 * ADD BN0147 19 98
 * ADD BM6982 10 25
 * ORDER
 * TOP BN0147
 * REMOVE AC5572
 * REVERSE
 *
 * 【样例输出】
 * BM6983 10 25
 * BM6982 10 25
 * BN0147 19 98
 *
 * ======================================================================================
 * 解题思路：
 *
 * 1. 数据结构：
 * - 定义结构体 Node: { char name[25]; int size; int weight; struct Node* next; }
 * - 维护链表头指针 head。
 *
 * 2. 操作实现：
 * - ADD: 遍历到链表尾部，插入新节点。(若链表为空，直接作为头)。
 * - TOP:
 * a. 找到目标节点 target 及其前驱 prev。
 * b. 如果 target 已经是头，无需操作。
 * c. 否则，断开链接 (prev->next = target->next)。
 * d. 将 target 插到头部 (target->next = head; head = target)。
 * - REMOVE:
 * a. 找到目标节点 target 及其前驱 prev。
 * b. 断开链接并 free(target)。注意处理删除头节点的情况。
 * - ORDER:
 * a. 由于数据量较小，可以使用冒泡排序思想交换节点数据 (Data Swapping)。
 * b. 编写 cmp 函数实现题目要求的复杂比较逻辑。
 * - REVERSE:
 * a. 经典链表反转算法 (使用 prev, curr, next 三个指针)。
 *
 * ======================================================================================
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 定义集装箱节点
typedef struct Node {
    char name[30];
    int size;
    int weight;
    struct Node* next;
} Node;

// 创建新节点
Node* createNode(char* name, int size, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    strcpy(newNode->name, name);
    newNode->size = size;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// 1. ADD 操作：尾插法
Node* addContainer(Node* head, char* name, int size, int weight) {
    Node* newNode = createNode(name, size, weight);
    if (head == NULL) {
        return newNode;
    }
    Node* p = head;
    while (p->next != NULL) {
        p = p->next;
    }
    p->next = newNode;
    return head;
}

// 2. TOP 操作：移至头部
Node* topContainer(Node* head, char* name) {
    if (head == NULL) return NULL;
    
    // 如果头节点就是要找的
    if (strcmp(head->name, name) == 0) {
        return head;
    }

    Node* prev = head;
    Node* curr = head->next;

    while (curr != NULL) {
        if (strcmp(curr->name, name) == 0) {
            // 找到目标，断开链接
            prev->next = curr->next;
            // 插到头部
            curr->next = head;
            return curr; // 新的头
        }
        prev = curr;
        curr = curr->next;
    }
    return head; // 未找到
}

// 3. REMOVE 操作：移除节点
Node* removeContainer(Node* head, char* name) {
    if (head == NULL) return NULL;

    // 如果删除头节点
    if (strcmp(head->name, name) == 0) {
        Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    Node* prev = head;
    Node* curr = head->next;

    while (curr != NULL) {
        if (strcmp(curr->name, name) == 0) {
            prev->next = curr->next;
            free(curr);
            return head;
        }
        prev = curr;
        curr = curr->next;
    }
    return head;
}

// 排序比较辅助函数
// 返回 >0 表示 a 应该排在 b 后面 (需要交换)
int shouldSwap(Node* a, Node* b) {
    // 规则1：尺寸从小到大
    if (a->size != b->size) {
        return a->size > b->size; 
    }
    // 规则2：重量从大到小
    if (a->weight != b->weight) {
        return a->weight < b->weight; // 注意这里是小于号，因为要大在前
    }
    // 规则3：编号字典序从小到大
    return strcmp(a->name, b->name) > 0;
}

// 4. ORDER 操作：排序 (冒泡排序交换数据版)
void orderContainers(Node* head) {
    if (head == NULL || head->next == NULL) return;

    int swapped;
    Node* ptr1;
    Node* lptr = NULL; // 标记已排序部分的边界

    do {
        swapped = 0;
        ptr1 = head;

        while (ptr1->next != lptr) {
            if (shouldSwap(ptr1, ptr1->next)) {
                // 交换数据
                char tempName[30];
                int tempSize, tempWeight;

                strcpy(tempName, ptr1->name);
                tempSize = ptr1->size;
                tempWeight = ptr1->weight;

                strcpy(ptr1->name, ptr1->next->name);
                ptr1->size = ptr1->next->size;
                ptr1->weight = ptr1->next->weight;

                strcpy(ptr1->next->name, tempName);
                ptr1->next->size = tempSize;
                ptr1->next->weight = tempWeight;

                swapped = 1;
            }
            ptr1 = ptr1->next;
        }
        lptr = ptr1;
    } while (swapped);
}

// 5. REVERSE 操作：链表反转
Node* reverseContainers(Node* head) {
    Node* prev = NULL;
    Node* curr = head;
    Node* next = NULL;

    while (curr != NULL) {
        next = curr->next; // 保存下一个
        curr->next = prev; // 反转指向
        prev = curr;       // 步进
        curr = next;
    }
    return prev; // prev 成为新的头
}

int main() {
    int n;
    if (scanf("%d", &n) != 1) return 1;

    Node* head = NULL;
    char cmd[20];
    char name[30];
    int size, weight;

    for (int i = 0; i < n; i++) {
        scanf("%s", cmd);

        if (strcmp(cmd, "ADD") == 0) {
            scanf("%s %d %d", name, &size, &weight);
            head = addContainer(head, name, size, weight);
        }
        else if (strcmp(cmd, "TOP") == 0) {
            scanf("%s", name);
            head = topContainer(head, name);
        }
        else if (strcmp(cmd, "REMOVE") == 0) {
            scanf("%s", name);
            head = removeContainer(head, name);
        }
        else if (strcmp(cmd, "ORDER") == 0) {
            orderContainers(head);
        }
        else if (strcmp(cmd, "REVERSE") == 0) {
            head = reverseContainers(head);
        }
    }

    // 输出结果
    Node* p = head;
    while (p != NULL) {
        printf("%s %d %d\n", p->name, p->size, p->weight);
        p = p->next;
    }

    return 0;
}
namespace GridPortal {
/*
 * ======================================================================================
 * 类别：动态规划 (DP) / 状态压缩 / 网格图
 * 题目：走格子 (2024-2025秋季学期 期末题)
 *
 * 【描述】
 * 给定 N*M 的网格，每个格子有权值。从 (1,1) 出发走到 (N,M)。
 * 只能向右或向下移动。
 * 存在 K 个双向传送门，每个传送门连接 (ax, ay) 和 (bx, by)。
 * - 传送门是一次性的。
 * - 进入端点会立即传送，传送后该门失效（不能再回传）。
 * - 传送门端点的权值保证为 0。
 * 求最小权值和。
 *
 * 【输入】
 * N, M (1 <= N, M <= 100)
 * N行 M列的权值矩阵 (绝对值 <= 100，可能有负数)
 * K (0 <= K <= 10)
 * K行传送门信息：ax, ay, bx, by
 *
 * 【输出】
 * 最小权值和。若无法到达输出 "No Way"。
 *
 * ======================================================================================
 */

#include <stdio.h>

#define MAX_N 105
#define MAX_K 12
#define INF 0x3f3f3f3f

// 记录传送门信息的结构
typedef struct {
    int u, v; // 端点1坐标
    int x, y; // 端点2坐标
} Portal;

Portal portals[MAX_K];
int grid[MAX_N][MAX_N];

// dp[mask][i][j]
// mask: 二进制状态，第 p 位为 1 表示第 p 个传送门已使用
// 空间估算：2^10 * 100 * 100 * 4字节 ≈ 40MB，符合内存要求
int dp[1 << 10][MAX_N][MAX_N];

// 辅助数组：快速查找某个坐标是否是传送门端点
// portal_map[i][j] = p+1 (表示是第p个传送门的端点)，0表示不是
int portal_map[MAX_N][MAX_N];

int min(int a, int b) {
    return a < b ? a : b;
}

int main() {
    int n, m;
    if (scanf("%d %d", &n, &m) != 2) return 1;

    // 1. 读入网格权值
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &grid[i][j]);
            portal_map[i][j] = -1; // 初始化为 -1
        }
    }

    // 2. 读入传送门
    int k;
    scanf("%d", &k);
    for (int p = 0; p < k; p++) {
        scanf("%d %d %d %d", &portals[p].u, &portals[p].v, &portals[p].x, &portals[p].y);
        // 记录映射，方便O(1)查找
        portal_map[portals[p].u][portals[p].v] = p;
        portal_map[portals[p].x][portals[p].y] = p;
    }

    // 3. 初始化 DP
    int total_masks = 1 << k;
    for (int mask = 0; mask < total_masks; mask++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[mask][i][j] = INF;
            }
        }
    }

    // 起点初始化
    // 注意：起点可能是传送门吗？题目保证端点不出现在起点终点。
    dp[0][1][1] = grid[1][1];

    // 4. 开始 DP
    // 外层循环：枚举 mask（状态从小到大，保证无后效性）
    // 因为传送门只能增加 mask 中的 1，所以从小到大遍历是安全的
    for (int mask = 0; mask < total_masks; mask++) {
        
        // 内层循环：遍历网格 (拓扑序：从上到下，从左到右)
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                
                // 如果当前状态不可达，跳过
                if (dp[mask][i][j] == INF) continue;

                int current_cost = dp[mask][i][j];

                // --- 尝试 1: 普通移动 (向右 / 向下) ---
                // 只有当当前格子不是“未使用的传送门端点”时，才能普通走出去？
                // 题目说：进入端点会“立即”传送。这意味着你不能停留在端点，也不能从端点普通走出。
                // 你走到端点的那一刻，就已经被传送到另一头了。
                // 所以，如果 (i,j) 是某个未使用传送门 p 的端点，
                // 那么 dp[mask][i][j] 其实是一个中间状态，它必须立即触发传送，不能向右/下走。
                // 只有当 (i,j) 不是传送门，或者传送门已经在 mask 里用过了，才能普通移动。
                
                int p = portal_map[i][j];
                int is_active_portal = (p != -1 && !(mask & (1 << p)));

                if (!is_active_portal) {
                    // 向下移动
                    if (i + 1 <= n) {
                        dp[mask][i + 1][j] = min(dp[mask][i + 1][j], current_cost + grid[i + 1][j]);
                    }
                    // 向右移动
                    if (j + 1 <= m) {
                        dp[mask][i][j + 1] = min(dp[mask][i][j + 1], current_cost + grid[i][j + 1]);
                    }
                } 
                else {
                    // --- 尝试 2: 触发传送 ---
                    // 当前位置是传送门 p 的一端，且 mask 显示未被使用
                    // 必须传送！不能普通移动。
                    
                    int next_mask = mask | (1 << p);
                    
                    // 确定传送的目标坐标
                    int tx, ty;
                    if (i == portals[p].u && j == portals[p].v) {
                        tx = portals[p].x;
                        ty = portals[p].y;
                    } else {
                        tx = portals[p].u;
                        ty = portals[p].v;
                    }
                    
                    // 状态转移
                    // 传送本身代价为0，且端点权值为0。
                    // 到达 (tx, ty) 后，权值和不变（因为 grid[tx][ty] 也是 0）
                    // 但我们需要把状态更新到 dp[next_mask][tx][ty]
                    
                    dp[next_mask][tx][ty] = min(dp[next_mask][tx][ty], current_cost);
                }
            }
        }
    }

    // 5. 统计答案
    // 终点 (n, m) 可能在任何 mask 状态下到达
    int ans = INF;
    for (int mask = 0; mask < total_masks; mask++) {
        if (dp[mask][n][m] < ans) {
            ans = dp[mask][n][m];
        }
    }

    if (ans == INF) {
        printf("No Way\n");
    } else {
        printf("%d\n", ans);
    }

    return 0;
}
}